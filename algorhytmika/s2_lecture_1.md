# ЛЕКЦИЯ 1

- Вычислительная сложность алгоритма
- Функции на последовательностях
- Индуктивные функции, универсальный алгоритм вычисления индуктивных функций
- Индуктивные расширения не индуктивных функций

## Вычислительная сложность алгоритма

Вычислительную сложность оценивают, во-первых, числом элементарных операций, необходимых для выполнения алгоритма. Под элементарными опрациями обычно понимают 4 арифметических действия +, -, *, /, операции сранения <, >, операцию копирования и т.п.

Во-вторых, вычислительная сложность определяется также необходимым для выполнения алгоритма объёмом памяти (выражаемым в байтах).

Обычно интерес передставляет зависимость вычислительной сложности алгоритма от "размера" задачи - некоторого параметра, от которого зависит сложность.

Например, если входные данные представлены массивом, то размер задачи есть длина массива.

Параметр задачи чаще всего обозначают буквой $n$.

Зависимость сложности алгоритма от параметра n выражают какой-либо функцией от этого параметра.

Обычно получить точную оценку сложности алгоритма затруднительно, или в этом нет необходимости. Как правило получают оценку сложности для "наихудшего случая", т.е. при наименее благоприятных исходных данных. Иногда также делают оценку в среднем по всем возможным входным данным.

В связи с этим часто при получении оценки сложности алгоритма в виде функциональной зависимости от параметра $n$ интересуются только тем, как ведет себя эта зависимость при больших $n$ ($n \rightarrow \infty)$

**Определение.** Говорят, что неотрицательная функция

$$f(n)=O(g(n)), \ \ n \rightarrow \infty$$

где $g(n)$ - некоторая другая неотрицательная функция, если существует такая положительная константа $C>0$, и такое натуральное число $n_0$, что

$$\forall n>n_0 \ \ \ f(n) <= C g(n)$$

Например, тот факт, что функция $f(n)$ является ограниченной, с помощью символики O-большое можно записать так: $f(n)=O(1)$.

Таким образом, то, что алгоритмическая сложность некоторого алгоритма оценивается для наихудшего случая как $O(g(n))$ означает, что число необходимых элементарных операций, или необходимый объем памяти, не превзойдет $C g(n)$.

При этом, если только это не ясно из контекста, всегда уточняют, идет ли речь о количестве операций или о объеме памяти.

## Примеры алгоритмов с оценкой их вычислительной сложности

Числовая последоватьельность $a_1, a_2, ..., a_n$  называется отсортированной по неубыванию, если

$$ a_1 <= a_2 <= ... <= a_n $$

### Алгоритм проверки, является ли заданная последовательность отсортированной по неубыванию

Ясно, что ответ может быть получен за однократный перебор в цикле всех элементов заданной последовательности. Поэтому вычислительная сложность данного алгоритма имеет оценку $O(n)$.

**Замечание.** В Julia имеется встроенная функция issorted, проверяющая, аяляется ли заданная последовательность отсортированной по невозрастанию, или - по неубыванию (в зависимости от значения именованного параметра rev; по умолчанию rev = false и, соответственно, проверяется отсортированность по не убыванию).

Причем имеется возможность передавать в эту функцию последовательности (итерируемые объекты), элементы которых сами состоят из элементов (например, кортежи, пары типа Pair, их которых состоят словари (Dict)), к которым можно обращаться с помощью индекса. Требуемое значение индекса по умолчанию равно 1, но может быть изменено заданием значения именованного параметра by. Значение этого параметра является функциональным. Например

```julia
  julia> issorted([(1, "b"), (2, "a")], by = x -> x[2])
  false

  julia> issorted([(1, "b"), (2, "a")], by = x -> x[2], rev=true)
  true
```

### Алгоритм "быстрого" поиска заданного значенния в отсортированной последовательности

Рассмотрим следующую задачу. Имеется отсортированная последовательность, представленная вектором A. Требуется проверить, содержит ли эта последовательность значение a.

Ясно, что задачу можно было бы решить просто последовательным перебором значений элементов последовательности. Однако, если учесть, что последовательность является отсортированной по неубыванию, то возможно реализовать алгоритм, вычисдительная сложность которого будет иметь оценку O(log(n)).

В самом деле, искомое значение можно сравнить с элементом последовательности из её середины. Если икомое значение окажется больше, то левую половину последовательности можно отбросить, в противном случае следует отбрасывать правую половину последовательности. В результате, если искомое значение содержится в массиве, то будет найден индекс соответствующего элемента массива, в противном случае такого индекса не существует.

**Замечание.** В языке Julia имеется встроенная функция searchsorted, реализующая быстрый поиск в массиве.

## Функции на последовательностях

Пусть задана последовательность объектов некторого типа:

$$ a_1, a_2, ..., a_n $$

где $a_k \in \Omega$  - некоторое множество (определяющее тип последовательности)

Будем использовать обозначения:

$$ A=[a_1,a_2,...,a_n]\in \Omega^n=\underbrace{\Omega\times...\times\Omega}_n $$

$$ \Omega^0={[\ ]} $$

где $[ \ ]$ - это пустая последовательность.

Также для множества всех последовательностей конечной длины (включая и пустую последовательность) будем использовать обозначение

$$ {\Sigma}=\bigcup_{n=0}^{\infty}{\Omega^n} $$

Тогда какую-либо функцию, определенную на всех последовательностях конечной длины с элементами из $\Omega$, со значениями в некотором множестве $U$ будем, как это принято в математике, обозначать:

$$ F:\Sigma\rightarrow U. $$

## Примеры функций на последовательностях и алгоритмы их вычисления

Длина последовательности:

$$ F(A)=length(A) \in \N \cup \{0\} $$

Вычисление этой функции сводится к вычислению n-го члена следующей вспомогательной последовательности:

$$ l_0=length([\ ])=0$$
$$ .... $$
$$ l_k=l_{k-1}+1 $$
$$ .... $$
$$ l_{n}=l_{n-1}+1 $$

Соответствующий программный код на языке Julia выглядит так:

```julia
function length_(A)
    len = 0
    for _ in A
        len += 1
    end
    return len
end
```

**Замечание.** В языке Julia имеется встроенная функции length, однако она не вычисляется по этому алгоритму. Длина массива - это просто внутренний атрибут массивов Julia. Поэтому сложность встоенного алгоритма оценивается как O(1), а не - О(n), как в случае функции length_.

### Сумма членов последовательности

$$ F(A)=sum(A)=\sum_{k=1}^na_k\ \in U=\Omega $$

Вычисление этой функции сводится к вычислению n-го члена следующей вспомогательной последовательности: 

$$ s_0=sum([\ ])=0 $$
$$ .... $$
$$ s_{k}=s_{k-1}+a_k $$
$$ .... $$
$$ s_{n}=s_{n-1}+a_n $$

Соответствующий программный код на языке Julia выглядит так:

```julia
function sum_(A)
    s = eltype(A)(0)
    for a in A
        s += a
    end
    return s
end
```

**Замечание 1.** В строке s = eltype(A)(0), по сути, переменной s присваиваивается просто значение нуля, но важно сразу определить, какого типа должен быть этот нуль. Встроенная функция eltype определяет тип элементов массива, получаемого в качестве аргумента.

Далее, поскольку значение типа - это, по существу, есть имя конструктора типа, то передав этому конструктору в качестве аргумента значение 0 (типа Int64), мы получим значение нуля нужного типа. Эта операция называется **явным преобразованием типа**. Явным - потому, что конструктор, осуществляющий такое преобразование вызывается явно.

Определение типа начального значения переменной s важно потому, что если этого не сделать, и присвоить, например, просто s=0, то, если в действительности в массиве A будут элементы другого типа, например, Float64, то после выполнения очередной операции сложения тип переменной s должен будет поменяться на Float64 (типизация в Julia динамическая). Этот эффект называется **нестабильностью типа**. Нестабильность типа не позволяет компилятору генерировать максимально производительный код, поэтому нестабильности типа, по возможности, следует избегать.

В рассматриваемом случае предотвратить нестабильность типа можно было бы сделать ещё и так:

```julia
function sum_(A::AbstractVector{T}) where T
    s = T(0)
    for a in A
        s += a
    end
    return s
end
```

где выражение where T в заголовке функции означает, что T - это формальный параметр, т.е. символическое имя, обозначающий некоторый тип. Этот тип будет определен (выведен динамическим компилятором) из значеия фаутического параметра, с которым будет вызвана функция sum_.

**Замечание 2.** В отличие от языков со стактической компиляцией, таких как C/C++, где типы данных существуют во время компиляции, а во время выполнения кода никаких типов данных уже нет. В языке Julia, в котором компиляция - динамическая, значение типа данных это такое же значение, как и значение любого другого типа, и поэтому может использоваться во время выполнения кода.

Строки s = eltype(A)(0) или, во втором случае, s = T(0) как раз и демонстрируют использование значения типа во время выполнения функции.

**Замечание 3.** В языке Julia имеется встроенная функция sum (однако встроенная функция sum является значительно более универсальной по сравнению с функцией sum_; см. help).

### Произведение членов последовательности

$$ F(A)=prod(A)=a_1 \cdot\ ... \cdot a_n=\prod_{k=1}^na_k\ \in U=\Omega $$

Вычисление этой функции сводится к вычислению n-го члена следующей вспомогательной последовательности:

$$ p_0=prod([\ ])=1 $$
$$ .... $$
$$ p_{k}=p_{k-1} \cdot a_k $$
$$ .... $$
$$ p_{n}=p_{n-1} \cdot a_n $$

Соответствующий программный код на языке Julia выглядит так:

```julia
function prod_(A)
    p = eltype(A)(1)
    for a in A
        p *= a
    end
    return p
end
```

**Замечаеие 1.** В сторке p = eltype(A)(1) переменной p, по сути, присваивается значение 1. Однако во избежание нестабильности типа (см. пример выше) здесь осуществлено явное перобразование типа.

**Замечание 2.** В языке Julia имеется встроенная функция sum (однако встроенная функция sum является значительно более универсальной по сравнению с функцией prod_; см. help).

### Максимальное значение членов последовательности

$$ F(A)=maximun(A)=\max(a_1,...,a_n)\ \in U=\Omega $$

Вычисление этой функции сводится к вычислению n-го члена следующей вспомогательной последовательности:

$$ M_0=maximum([\ ])=-\infty $$
$$ .... $$
$$ M_{k}=\max(M_{k-1},a_k) $$
$$ .... $$
$$ M_{n}=\max(M_{n-1},a_n) $$

Соответствующий программный код на языке Julia выглядит так:

```julia
function maximum_(A)
    M = typemin(eltype(A)) # m = -Inf
    for a in A
        M = max(M,a)
    end
    return M
end
```

**Замечание.** В языке Julia имеется встроенная функция maximum (однако встроенная функция maximum является значительно более универсальной по сравнению с функцией maximum_; см. help).

## Минимальное значение членов последовательности

$$ F(A)=minimun(A)=\min(a_1,...,a_n) \ \in U = \Omega. $$

Вычисление этой функции сводится к вычислению n-го члена следующей вспомогательной последовательности: 

$$ m_0=minimum([ \ ]) = \infty $$
$$ .... $$
$$ m_{k}=\min(m_{k-1},a_k) $$
$$ .... $$
$$ m_{n}=\min(m_{n-1},a_n) $$

Соответствующий программный код на языке Julia выглядит так:

```julia
function maximum_(A)
    m = typemin(eltype(A)) # m = -Inf
    for a in A
        m = min(m,a)
    end
    return m
end
```

**Замечание.** В языке Julia имеется встроенная функция minimum; см. help.

### Индекс максимального значения членов последовательности

$$ F(A)=\argmax(A) $$

это значение индекса элемента, при котором элемент достигает наибольшего значения, т.е.

$$ maximum(A)=A[\argmax(A)] $$

Вычисление этой функции сводится к вычислению следующей вспомогательной последовательности:

$$ i_{max \ 1}=maximum([a_1])=1 $$
$$ ... $$
$$ i_{max\ k}=A[k]>A[k-1]\ ?\ k : i_{max \ k-1} $$
$$ ... $$
$$ i_{max \ n}=A[n]>A[n-1]\ ?\ n : i_{max \ n-1} $$

Соответствующий программный код на языке Julia выглядит так:

```julia
function argmax_(A)
    @assert !isempty(A)
    imax = firstindex(A)
    for k in eachindex(A)
        if A[k] > A[imax] 
            imax = k
        end
    end
    return imax
end
```

**Замечание 2.** В языке Julia имеется встроенная функция argmax (однако эта функция является значительно более универсальной по сравнению с функцией argmax_). Имеется также и аналогичная встроенная функция argmin(A); см. help.

## Значение многочлена в точке, вычисленное по последовательности его коэффициентов, заданной по убыванию степеней, по хеме Горнера

$$ P_n(x)=a_0 \cdot x^n + a_1 \cdot x^{n-1} + ... + a_{n-1} \cdot x + a_n $$

Будем считать, что задан массив коэффициентов $A=[a_0,a_1,...a_n]$, и некторое значение аргумента $x$. Тогда $F(A)=P_n(x).$

Для вычисления этой функции воспользуемся следующей вспомогательной последовательностью многочленов:

$$ Q_0(x)=a_0 $$
$$ Q_1(x)=Q_0 \cdot x + a_1 = a_0 \cdot x + a_1 $$
$$ .... $$
$$ Q_k(x)=Q_{k-1} \cdot x + a_k $$
$$ .... $$
$$ Q_n(x) = Q_{n-1} \cdot x + a_n = P_n(x) $$

Соответствующий программный код на языке Julia выглядит так:

```julia
function evalpoly_(x,A)
    Q = first(A) # - это есть a_0
    for a in @view A[2:end]
        Q=Q*x+a
    end
    return Q
end
```

**Замечание.** В языке Julia имеется встроенная функция evalpoly, реализующая данный агоритм; см. help. Кроме того, для работы с многочленами в языке Julia имеется также специальный пакет Polynomials.jl (см. https://github.com/JuliaMath/Polynomials.jl)

## Индуктивные функции на последовательностях

Зададимся вопросом: что общего у всех рассмотреннных выше функций на последовательностях? Чтобы ответить на этот вопрос с математической точностью, понадобится следующее определение.

**Определение.** Функция $F:\Sigma\rightarrow U$ называется индуктивной (по А.Г.Кушниренко), если существует такая функция двух переменных (операция) $op: U \times \Omega \rightarrow U$, такая, что для любой последовательности A $\in \Sigma$ и для любого нового элемента a $\in \Omega$,

$$ F([A...,a])=op(F(A),a), $$

где [A..., a] = [A[1], ..., A[end], a]

Как можно убедиться все рассмотренные выше функции являются индуктивными.

Так, в случае F(A)=length(A), op(L,a)=L+1 (зависимость от второго аргумента здесь только формальная);

- в случае F(A)=sum(A), op(s, a) = s+a;

- в случае F(A)=prod(A), op(p, a) = p*a;

- в случае F(A)=maximum(A), op(M, a) = max(M, a);

- в случае F(A)=minimum(A), op(m, a) = min(m, a);

- в случае F(A)=argmax(A), op(imax, A[k]) = A[k] > A[imax] ? k : imax;

- в случае F(A)=$P_n(x)$, op(Q, a) = Q*x + a;

наконец, в случае F(A) = insertsort!(A), op(A[1:k], A[k+1]) = end_insert!(A[1:k+1]).

Можно заметить, что вычисление любой индуктивной функции можно свести к следующей универсальной схеме (алгоритму), точнее говоря, рассматриваемая ниже схема может иметь незначительные вариации, связанные с инициализацией переменной, в которой затем формируется результат вычислений:

```julia
y = F([]) # значение индуктивной функции на пустой последовательности 
for a in A
    y = op(y,a)
end
```

Здесь под $A$ понимается некоторый итерируемый объект, представляющий последовательность. Не обязательно это именно массив, это также может быть и кортеж, и диапазон, и генератор, и какой-либо контейнер, например, множество.

При этом функцию F(A) необходимо доопределять на пустой последовательности таким значением, нейтральным по отношению к опрерации op.

Например, при вычислении суммы чисел, таким нейтральным значением будет число 0, при вычислении произведения чисел, нейтральным значением будет число 1, при поиске минимального элемента, нейтральным значением будет символ бесконечности, при сортировке массива (вставками) - пустой массив.

Но иногда удобнее обходиться без доопределения вычисляемой функции на пустой последовательности, тогда алгоритм примет вид:

```julia
y = F([A[1]]) # значение индуктивной функции на подпоследовательности, содержащей только первый элемент A
for a in A[2:end]
    y = op(y,a)
end
```

Вообще, начинать вычисления можно не только с пустой последовательности, или с последовательности из одного элемента, но и - с последовательности, содержащей любое другое число начальных элементов.

При программировании вычислений индуктивной функции требуется рассматривать входные данные как последовательность некоторых значений, в требуемом порядке поступающих для "обработки".

**Замечаие.** Если функция на последовательности является индуктивной, то в нашем распоряжении имеется рассмотренный здесь универсальный алгоритм ее вычисления. Для записи этого алгоритма требуется только инициализачия начального значения переменной y (в нашей записи) и конкретизация операции op, т.е. определение соответствующей функции 2-х переменных.

## Встроенная функция reduce

Для вычисления любой индуктивной функцийив языке Julia есть универсальная reduce, являющаяся функцией высшего порядка (в языке Python также имеется подобная функция, с тем же именем):

```julia
reduce(op, itr; [init])
```

где

op - это аргумент типа Funсtion, определяющий рекурсивную опрерацию, т.е. соответствующую функцию 2-х аргументов;
itr - это итерируемый объект, задающий последовательность (например, одномерный массив);
init - необязательный именованный аргумент (квадратные скобки обозначают, как это принято в прграммировании, что параметр необязательный), определяет значение, которым доопределяется вычисляемая индуктивная функция на пустой последовательности. При отсутствии этого аргумента, вычисление будет осуществляться в соответствии со вторым вариантом универсального алгоритма.

Например, функция sum, могла бы быть определена следующим образом:

```julia
sum_(A)=reduce(+, A; init=eltype(A)(0))
```

В этом случае sum([]) вернет 0.0 (тип результата будет именно Float64, потому что аргумент eltype([]) имеет значение Float64).

А если определить функция sum так:

```julia
sum_(A)=reduce(+, A)
```

то вызов sum([]) приведет к ошибке (функция не определена на пустой последовательности).

Точно также, в одну сточку, можно было бы реализовать и рассмотренную ранее функцию eval_poly(x,A), вычисляющую значение многочлена в точке по схеме Горнера:

```julia
evalpoly_(x,A)=reduce((Q,a)->Q*x+a, A)
```

## Сортировка числового массива вставками

Задача сортировки массива A состоит в том, чтобы переставить его элементы так, чтобы получилось: A[1] <= A[2] <=...<= A[end].

Существует множество популярных алгоритмов сортировки, разной алгоритмической сложности. Но далеко не все из них можно рассматривать как вычисление индуктивной функции на последовательности. Однако есть одно исключение - это так называемый алгоритм сортирвки вставками.  

Идея сортировки вставками состоит в том, что если первые k элементов массива A уже отсортированы, то для того, чтобы получить отсортированными первые k+1 элементов этого массива, достаточно просто вставить eго k+1-ый элемент в соответствующую позицию, сдвигая поочередно все элементы, которые больше его, на 1 позицию вправо. Поскольку для k=1 необходимое предположение об отсортированности начальной части массива всегда выполнено, то остается только проитерировать k от 2 до n (n=length(A).)

Сортировка массива A, в этом случае F(A) = sort(A) $\in \Sigma$ - есть индуктивная функция.

Соответствующая функция на языке Julia могла бы выглядеть так:

```julia
function insertsort!(A)
    n=length(A)
    for k in eachindex(A) #2:n
        # часть массива A[1:k-1] уже отсортирована
        op_insert!(A,k)
    end
    return A
end

op_insert!(A,k) =
    while k>1 && A[k-1] > A[k]
        A[k-1], A[k] = A[k], A[k-1]
        k -= 1
    end
```

Сложность алгортма сортировки вставками оценивается как $O(n^2)$.

**Вопрос:** можно ли добиться оценки сложности сортировки массива вставками, если вставку осуществлять на основе алгоритма быстрого поиска?

**Ответ:** нет нельзя. (Почему?)

## Однопроходные алгоритмы

Под однопроходым алгоритмом понимаются алгорим, который выдаёт ответ в результате однократного перебора элементов некоторой последовательности, представляющей исходные данные. Сложность всех однопроходных  алгоритмов может быть оценена как O(n), где n - это длина последлвательности.

В этом смысле универсальная схема вычисления индуктивной функции на последовательности всегда даёт однопроходный алгоритм, но только при условии, что выполняемая на каждом шаге такого алгоритма операция (op) имеет асимптотическую оценку сложности - $O(1)$.

Например, все рассмотренные выше алгоритмы вычисления индуктивных функций, за исключением сортировки вставками, являются однопроходными.

Сортировка вставками не является однопроходным алгоритмом. Сложность операции вставки в алгоритме сортировки вставками оценивается только как $O(n)$ (даже если применить алгоритм быстрого поиска; имеется ввиду, что последовательность представлена массивом, см. выше).

## Индуктивные расширения неиндуктивных функций

Пусть

$$ F(A)=mean(A)=sum(A)/length(A) $$

Эта функция не является индуктивной. Доказать это можно, разсуждая от противного. В самом деле, предположим, согласно определению индуктивной функции, что существует такая функция двух переменных $op(m, a)$, такая, что для любых $A \in \Sigma$ и $a \in \Omega$,

$$ mean([A[1],...,A[end], a])=op(mean(A),a) $$

Тогда это означало бы, что величины $mean(A)$ и $a$ однозначно определяют результат.

С другой стороны,

$$ mean([A[1],...,A[end], a])=\frac{sum(A)+a}{length(A)+1}=\frac{mean(A)+\frac{a}{length(A)}}{1+\frac{1}{length(A)}} $$

Отсюда видно, что значения $mean(A)$ и $a$ сами по себе не определяют величину $mean([A...,a])$, т.к. тут имеется еще зависимость от $length(A)$, причем между $mean(A)$ и $length(A)$, очевидно, нет взаимно однозначного соответствия. Таким образом, приходим к противоречию.

Однако, функции $sum(A)$ и $length(A)$, как мы знаем, сами по себе являются индуктивными. Поэтому, функция на последовательностях, значениями которой будет пара значений (кортеж значений):

$$ F^*(A)=(sum(A), length(A)) $$

уже будет индуктивной.

Эту индуктивную функцию можно вычислить с использование универсального алгоритма, а интересующая нас не индуктивная функция $mean(A)$ уже просто выражается через ее компоненты.

**Определение.** Функция

$$ F^*: \Sigma \rightarrow U^* $$

называется индуктивным расширение не индуктивной функции $F(A)$, если существует функция

$$ P: U^* \rightarrow U $$

такая, что для любой последовательности $А \in \Sigma$

$$ F(A)=P(F^*(A)) $$

В частности, в случае не индуктивной функции $mean(A)$ её индуктивным расширением будет функция

$$ F^*(A)=(sum(A),length(A)) $$

При этом

$$ mean(A)=\frac{sum(A)}{length(A)}=\frac{F^*(A)[1]}{F^*(A)[2]} $$

### Примеры построения индуктивных расширений неиндуктивный функций

**Пример 1.** Функция mean(A), вычисляющая среднее арифметической последовательности, он уже был рассмотрен.

**Пример 2**. Наибольшее значение в заданной последовательности может быть не единственным (может существовать несколько членов последовательности, иеющих максимальное значение).

Пусть требуется посчитать число максимальных элементов в заданной последовательности. Число максимальных элементов, очевидно, не является индуктивной функцией на последовательностях.

В самом деле, если известно число максимальных элементов в некоторой начальной части заданной последовательности, и получено значение еще одного, следующего, члена последовательности, то не известно, как правильно должно изменится общее число максимумов - это зависит от значения самого максимума: либо новый член последовательности меньше максимума, тогда число максимумов останется прежним, либо он равен прежнему максимуму, и тогда общее число максимумов надо увеличить на 1, либо его значение больше прежнего максимума, и тогда число максимумов должно быть положено равным 1.

Таким образом, ясно, что индуктивным расширением, в данном случае, будет кортеж из двух значений: число максимумов и само максимальное значение.

**Пример 3.** Вычисление значения многочлена и его производной в точке, по заданной последовательности его коэффициентов, по схеме Горнера.

Пусть некоторый многочлен задан последовательностью своих коэффициентв, с ледующих в порядке убывания степеней, т.е.  пусть $a_0$ - это коэффициент при степени $n$ (старшая степень), $a_1$ - коэффициент при степени $n-1$ и т.д. Требуется вычислить значение значение **производной** этого многочлена в заданной точке $x$, причем используя для этого минимально возможное число арифметических операций.

Ясно, что если задачу рассматривать как вычисление функции на последовательности $a_0, a_1,..., a_n$, то, в отличие от значения самого многочлена, вычисляемого по схеме Горнера, значение его производной не является индуктивной функцией.

В самом деле, пусть

$$ P_n(x) = a_0 x^n + a_1 x^{n-1} + ... + a_n $$

Как и в схеме Горнера рассмотрим вспомогательную последовательность многочленров $Q_k(x), k = 0,1,2,...,n$:

$$ Q_0(x) = a_0 $$

$$ Q_1(x) = a_0 x + a_1 $$

...

$$ Q_{k+1}(x) = Q_k(x)x + a_{k+1} $$

...

$$ Q_n(x) = P_n(x) $$

Ясно, что если при некотором $k$ известно значение  $Q'_k(x)$, то получив дополнительно ещё только очередное значение $a_{k+1}$ невозможно будет однозначно определить значение $Q'_{k+1}(x)$ (потребуется ещё значение самого многочлена $Q_k(x)$).

Действительно, дифференцируя выражение

$$ Q_{k+1}(x) = Q_{k}(x)x + a_{k+1} $$

где $k=0,1,2,...$, получим

$$ Q'_{k+1}(x) = Q'_k(x)x + Q_k(x) $$

Откуда видно, что для вычисления Q'_{k+1}(x) требуются сразу обе эти рекуррентные формулы $($т.к. $Q_k(x)$ не может быть однозначно выражено через $Q'_k(x))$, с начальными условиями

$$Q_0(x)=a_0, \ \ Q'_0(x) = 0$$

Таким образом, полученные рекуррентные формулы определяют индуктивное расширение

$$ F^*(a_0,...,a_k) = (Q_k(x); Q'_k(x)) $$

не индуктивной функции

$$ F(a_0,...,a_k) = Q'_k(x) $$

**Пример 4.** Вычисление наибольшего значения суммы непрерывного сегмента числовой последовательности.

Пусть имеется числовая последовательность $a_1, a_2,..., a_n$.

Требуется найти однопроходный алгоритм вычисления величины

$$ M_n = \max_{i,j} \sum_{m=i}^{j} a_m $$

где максимум ищется по всем парам индексов $i,j$, таким, что $0<=i<=j<=n$.

Если бы последовательность содержала только неотрицательные числа, то задача свелась бы к простому суммированию всей последовательности, полагая $i=1, j=n$.

Однако если среди членов последовательности имеются и положительные, и отрицательные, то возникает проблема выбора оптимальных значений $i$ и $j$.  

Как и во всех случаях, когда требуется получить однопроходный алгоритм, необходимо понять, какую информацию, полученную на $k$-ом шаге алгоритма надо сохранять (в соответствующих переменных), чтобы на следующем шаге иметь возможность выдать ответ уже для последовательности $a_1, a_2,..., a_k, a_{k+1}$.

Обозначим через $M_k$ - интересующее нас значение для последовательности $a_1, a_2,..., a_k$.

Введем дополнительную величину
$$M^*_k = \max_i \sum_{m=i}^{k} a_m $$

где максимум ищется только по нижнему пределу $i$ индекса суммирования $m$, при фиксированом его верхнем пределе, равном $k$.

Тогда, очевидно, имеем

$$ M^*_{k+1} = max\{M^*_k+a_{k+1}, \ a_{k+1}\}$$

$$ M_{k+1}=max\{M^*_{k+1}, M_k\} $$

Таким образом, имеем индуктивное расширение

$$F^*(a_1,...,a_k) = (M^*_k; M_k)$$

неиндуктивной функции

$$F(a_1,...,a_k) = M_k$$
