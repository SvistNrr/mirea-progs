# Лекция 4

- Встроенные целые типы (встроенная функция `typemax`).
- Пользовательский тип - кольцо вычетов целых чисел (`Residue`).
- Пользовательский тип - многочлен над кольцом или полем (`Polynomial`).
- Кольцо многочленов над некоторым полем.
- Вычисления с плавающей точкой (встроенные функции `floatmax`, `eps`, `maxintfloat`).

## Встроенные целые типы

Рассмотрим встроенные целые беззнаковые типы `UInt8`, `UInt16`, `UInt32`, `UInt64`.

Каждый из них представляют собой кольцо вычетов целых чисел по модулю `2^8`, `2^16`, `2^32` и `2^64`, соответственно, и, таким образом, значения этих типов принадлежат диапазонам: `0:2^8-1`, `0:2^16-1`, `0:2^32-1` и `0:2^64-1`.

Каждый из перечисленных диапазонов явлется представлением класса вычетов целых чисел по соответствующему модулю с помощью так называемой несимметриченой системы остатков.

Встроенные знаковые целые типы: `Int8`, `Int16`, `Int32`, `Int64` также передставляют собой те же классы вычетов по модулю `2^8`, `2^16`, `2^32` и `2^64`, соответственно. Но при этом классы вычетов будут представлены уже симметричными системами остатков, т.е. диапазонами: `-2^7:2^7-1`, `-2^15:2^15-1`, `-2^31:2^31-1`, `-2^63:2^63-1`, соответственно.

Таким образом, арифметические операции с целыми числами этих типов выполняются как с элементами той или иной системы остатков, представляющей соответствующий класс вычетов целых чисел.

Поэтому встроенные целые типы конечной длины не представляют кольцо всех целах чисел, а лишь моделируют опрерации с целыми числами. Причем, если в операциях участвуют слишком большие числа, то будут появляться ошибки переполнения, возможность которых всегда необходимо иметь ввиду.

Можно считать, что встроенный тип длинных целых `BigInt` реализует кольцо всех целых чисел, но вычисления с такими числами, по понятным причинам, являются очень затратными.

## Пользовательский тип - кольцо вычетов

Займемся теперь проектированием пользовательского типа данных, предназначенного для представления классов вычетов целых чисел по произвольному модулю (в виде несимметричной системы остатков).

```julia
struct Residue{T, M}
    value::T
    Residue{T,M}(value) where {T,M} = new(value ÷ M) 
end
```

Здесь нам пришлось переопределить конструктор типа `Residue`, определяемый по умолчанию, т.к. при присваивании полю `value` значения необходимо гарантировать, чтобы оно находилось в диапазоне `0:M-1`

Теперь, например, при создании объекта

```julia
a = Residue{Int,5}(7)
```

в поле value будет гарантировано записано число `2`.

Далее остается определить операции над элементами кольца вычетов

```julia
Base. +(a::Residue{T,M}, b::Residue{T,M}) where{T,M} = (a.value + b.value) ÷ M
Base. *(a::Residue{T,M}, b::Residue{T,M}) where{T,M} = (a.value * b.value) ÷ M

function Base.inv(a::Residue{T,M})::Union{Nothing, Residue{T,M}} where{T,M}
    #=
    Если элемент кольца вычетов a обратим, то обратный элемент может быть вычислен с использованием расширенного алгоритма Евклида (см. лекцию 3). В противном случае следует вернуть nothing
    =#
    ........................... # дальнейший код предлагается написать самостоятельно
end
```

Основываясь на функции inv целесообразно будет определить операцию деления

```julia
Base. /(a::Residue{T,M}, b::Residue{T,M}) where{T,M} = a * inv(b)
```

Так же может быть полезно определить в кольце вычетов унарный минус и, основанную на нем операцию вычитания:

```julia
Base. -(a::Reidue{T,M})where{T,M} = Residue{T,M}(M - a.value)

Base. -(a::Residue{T,M}, b::Residue{T,M}) = a + (-b)
```

Кроме этого, можно было бы определить ещё операции `==`, `===`, `<`, `>`, `<=`, `>=`, и дополнительно ещё операцию  сравнения (`==`) с `0` типа `Int64` (а также можно было бы определить ещё и операции сравнения с нулями всех остальных встроенных целых типов).

## Пользовательский тип - многочлен

```julia
struct Polynomial{T}
    coeff::Vector{T}

    function Polynomial{T}(coeff) where T 
        n = 0
        for c in reverse(coeff)
            if c == 0
                n+=1
            end
        end
        new(coeff[1:end-n])
    end
end
```

**ТУТ БЫЛО НЕ ХОРОШЕЕ УТВЕРЖДЕНИЕ: !!!! "В данном случае существующий конструктор по умолчанию нас вполне устраивает."**

Пример использования конструктора

```julia
p = Polynomial{Int}([1,2,3.0]) 
```

Естественно будет определить функцию, возвращающую порядок многочлена:

```julia
deg(p::Polinomial) = length(p.coeff) - 1
```

Далее, чтобы определить операции с многочленами, нужно договориться о том, в каком порядке перчисляются коэффициенты в векторе коэффицентов, т.е. - о том перечисляются они в порядке возрастания степеней, или наоборот - в порядке убывания.

Пусть, например, многочлены представляются последовательностями коэффициентов по возрастанию степеней, тогда:

```julia
function Base. +(p::Polinomial{T}, q::Polinomial{T})::Polinomial{T} where T
    np, nq = length(p.coeff), length(q.coeff)
    if  np >= nq 
        coeff = similar(p.coeff)
        coeff[1:nq] .= (@view(p.coeff[1:nq]) .+ q) 
    else
        coeff = similar(q.coeff)
        coeff[1:np] .= (p .+ @view(q.coeff[1:np]))
    end
    # При сложении некоторые старшие коэфициенты могли обратиться в 0 
    i, n = lastindex(coeff), 0
    while i > 0 && coeff[i] == 0
        n += 1
        i -= 1
    end
    # n = число нулей в конце массива coeff, соответсвующих старшим степеням  
    resize!(coeff, length(coeff)-n)
    return Polinomial{T}(coeff)
end
```

**Замечание.** Если бы многочлены представлялись последовательностями коэффициентов по убыванию степеней, то после сложения многочленов нули могут появиься в начале массива `coeff`. Тогда прежде чем применять к этому массиву функцию `resize!` (изменяющую размер массива), потребовалость бы сначала произвести сдвиг элементов массива `coeff` на соответствующее число позиций влево.

Тут уже требуется линейный сдвиг на `n` позиций влево, который мог бы быть произведен так:

```julia
coeff(1:end-n) .= @view(coeff[n+1:end])
```

Аналогично сложению многочленов можно определить и операцию их вычитания:

```julia
function Base. -(p::Polinomial{T}, q::Polinomial{T})::Polinomial{T} where T
    ....... # предлагается сделать это самостоятельно
end
```

```julia
function Base. *(p::Polinomial{T}, q::Polinomial{T})::Polinomial{T} where T
    coeff = zeros(T, deg(p) + deg(q)+1)
    for i in eachindex(p.coeff), j in eachindex(q.coeff)
            coeff[i+j - 1] += p.coeff[i]*q.coeff[j]
    end
    .....
    # Возможно, что коэффициет при старшей степени окажется равным нулю.
    # Поэтому предлагается самостоятельно вставить на место многоточий соответствующий код, 
    # в котором это проверялось бы, и, при необходимости, лишние нулевые элементы массива удалялись бы.
    return Polinomial{T}(coeff)
end
```

Кроме этого, было бы удобно предусмотреть ещё сложение, вычитание и умножение многочленов, когда один из них представлен просто числом (число тоже можно стчитать многочленом)

```julia

Base. +(p::Polinomial{T}, c::T) where T = +(p, Polinomial{T}([c]))
Base. +(c::T, p::Polinomial{T}) where T = +(Polinomial{T}([c]), p)

Base. -(p::Polinomial{T}, c::T) where T = -(p, Polinomial{T}([c]))
Base. -(c::T, p::Polinomial{T}) where T = -(Polinomial{T}([c]), p)

Base. *(p::Polinomial{T}, c::T) where T = *(p, Polinomial{T}([c]))
Base. *(c::T, p::Polinomial{T}) where T = *(Polinomial{T}([c]), p)

Далее, поскольку многочлены с коэффициентами из некоторого поля можно делить "уголком", получая частное и остаток в виде соответствующих многочленов, то полезными будут также определения следующих функций.

```julia
Base.div(p::Polinomial{T}, q::Polinomial{T})::Polinomial{T}where T = divrem(p,q)[1]
Base.rem(p::Polinomial{T}, q::Polinomial{T})::Polinomial{T}where T = divrem(p,q)[2]
```

Предполагается, что эти функции определены на основе функции `divrem(p,q)`, которую надо написать обобщенно, так, чтобы она могла быть использована для многчленов с коэффициентами из любого заданного поля (например, $\mathbb{R}, \mathbb{Q}, \mathbb{C}, \mathbb{F}_p$), представленного соответствующими встроенными  (`Float64`, `Rational`, `Complex`) или  пользовательскими (`Residue`) типами.

Наконец, для типа `Polinomial` было бы естественно обеспечитить возможность писать код в следующем стиле.

```julia
P = Polinomial{Int,[1,2,3]}
x = 0.5
y = P(x) # чтобы вычислить 1 + 2x + 3x^2
```

Это означает определить возможность "вызова объекта" (в данном случае - многочлена) на вычисление с данным значением аргумента `(x)`.

Такая возможность появится после следующего определения.

```julia
(p::Polinomial)(x) = polyval(reverse(p.coeff), x)
```

Смысл этого определения состоит в том, что оператор "вызова" представляет собой круглые скобки (в общем случае пустые или содержащие целый список аргументов), в данном случае это - `(x)`, применяется не к функции, как это бывает обычно, а к объету. Какие именно действия следует произвести с объектом и полученным аргументом записано справа от знака равенство.

В принципе, если бы эти действия не выражались бы всего лишь одной стокой, то их можно было бы записать точно также, как в таком случае это делается при определении функции:

```julia
function (p::Polinomial)(x) 
    polyval(reverse(p.coeff), x)
end
```

Только здесь вместо имени функции - объект с обязательным указанием его типа.

**Замечание.** Для работы с многочленами в Julia имеется пакет Polynomials.jl (который требует предварительной установки).

## Пользовательский тип - кольцо  вычетов многочленов над некоторым полем по заданному модулю

Чтобы работать с кольцом вычетов многочленов, нового типа определять не надо. Ранее определенный тип `Residue{T, M}` позволяет определить кольцо вычетов множества всех многочленов над каким либо полем по заданному модулю (в данном случае модулем будет некоторый  многочлен над тем же полем).

Например,

```julia
P = Residue{Rational{Int}, Polinomial{Rational{Int}, Rational[1,2,3]}}(Rational[1,2,3,4,5,6])
```

Теперь объект `P` передсдавляет многочлен с рациональными коэффицтентами, являющийся остатком от деления многочлена с коэффициентами `Rational[1,2,3,4,5,6]` (рациоальными), на многочлен с коэффициентами `Rational[1,2,3]` (рациональными).

## Вывод значений, функция display

В языке Julia для каждого типа данных, как встроенного, так и пользовательского определена (изначально) функция display. Эта функция автоматически вызывается всякий раз, когда значение того или иного типа выводится на экран (в REPL), причем формат, в котором значение выводися определяется функцией display.

Если мы определили новый тип данных, например, Polynom, то для него функция display будет определена по умолчанию.

Например,

```julia
julia> Polynomial{Int}([1,2,3])
Polynomial{Int64}([1, 2, 3])
```

Здесь была вызвана определенная по умолчанию функция функция display (поскольку в конце ввода не была поставлена точка с запятой, которая предотвратила бы этот вызов), и эта функция просто напечатала строку: "Polynomial{Int64}([1, 2, 3])".

Однако было бы нагляднее, если бы она вместо этого напечатала бы: "1+2x+3x^2".

Для обеспечения такого результата функцию display потребуется переопределить для нашего типа:

```julia
function Base.display(p::Polynomial)
    if isempty(p.coeff)
        return ""
    end
    str = "$(p.coeff[1])" # $(...) - означает "интерполяцию стоки", т.е. вставку в строку некоторого вычисляемого значения 
    for i in 2:length(p.coeff)
        if i > 2
            s = " + $(p.coeff[i])x^$(i-1)"
        else
            s = " + $(p.coeff[i])x"
        end
        str *= s
    end
    println(str)
end
```

В результате будет получиться вывод в виде:

```julia
julia> Polynomial{Int}([1,2,3])
1 + 2x + 3x^2
```

## Компьютерные числа с плавающей точкой

В языке Julia `Float64` - основной тип с плавающей точкой (соответствует типу double в C/C++).

Более короткие числа с плавающей точкой в серьезных вычислениях обычно не используются, так как не могут обеспечить численной устойчивости (численная устойчивость - это когда накопление ошибок округления всегда остается в приемлемых границах). Обычно они используются лишь для экономии памяти при представлении больших массивов данных, например, изображений.

Во внутреннем машинном представлении число с плавающей точкой представляется в виде знакового бита, двоичного кода порядка двоичного порядка $p$ числа и двоичного кода мантиссы $m$: $\pm m*2^p$.

Причем $1 \le m < 2$ - это условие означает, что мантиса представляется в так называемом **нормализованном** виде (сама мантисса в таком случае называется **нормализованной мантиссой**).

Чтобы получить строку из `64` битов, представляющих машинное число с плавающей точкой можно воспользоваться встроенной функцией `bitstring`, например:

```julia
julia> bitstring(2.2)
"0100000000000001100110011001100110011001100110011001100110011010"
```

Длина двоичной мантиссы зависит от типа данных, для Float64 она равна `53` битам. На самом деле в памяти хранится только `52` бита нормализованной мантиссы, т.к. ее первый бит всегда равен `1` и хранить его в памяти не имеет смысла. Оставшиеся `11` бит представляют двоичный порядок, который в памяти хранится в виде беззнакового целого. Однако это просто удобный способ кодирования, в действительности диапазон порядов нормализованных чисел типа `Float64` в перещете на десятичную систему счисления есть `-308:308`.

В Julia имеются встроенные функции `floatmin` и `floatmax`, возвращающие наимменьшее и наибольшее комьютерное нормализованное число с плавающей точкой заданного типа.

Напимер,

```julia
julia> floatmin(Float64)
2.2250738585072014e-308

julia> floatmax(Float64)
1.7976931348623157e308
```

Представить с помощью `Float64` число большее `floatmax(Float64)` не возможно. Однако существует значение данного типа, большее любого числа с плавающей точеой, но это не число, это значение `Inf` ("бесконечность"), которому тоже соответствуюе некоторый двоичный код.

Однако среди значений `Float64` имеются значения, меньшие `floatmin(Float64)` - это так называемы денормализованные числа, отрицательный порядок которых по абсолютной величине может превышать число `308`, но только за счет уменьшения длины мантисы (в этом и проявляется эффект денормализации). Наименьшее положительное денормализованное число приблизительно равно `2`.`5e-323`, т.е. на `15` порядков меньше минимального нормализованного числа.

Денормалиованные машинные числа могут появляться при делении какого-либо не большого числа на очень большие числа или при умножении на очень маленькие числа, и это явление будет приводить к потери точности вычислений.

Множество всех действительных чисел отображается на множество машинными числами с плавающей точкой (типа `Float64`, например), причем это отображение не взаимно однозначное.

Так все вещественные числа из диапазона от `-2e-324` до `2e324` (границы диапазона указаны приблизительно), отображаются в `0.0`. И этот диапазон вещественных чисел принято называть **машинным нулем**.

Всем положительным вещественным числам, по модудулю большим `floatmax(Float64)`, соответствует символ `Inf`, а всем отрицательным вещественным числам, по модулю большим, все того же значения `floatmax(Float64)` - соответствует значение `-Inf` (типа `Float64`).

Множество вещественных числ модули которых находятся между верхней границей машинного нуля и значением `floatmax(Float64)` также не взаимнооднозначно отображаются на множество машинных числел, которых имеется лишь конечное множество (хотя очень и очень большой мощности).

Поскольку длина мантиссы всегда `53` бита (если не брать в расчет денормализованные числа, которые на числовой оси располагаются рядом с машинным нулем), то при увеличении положительного двоичного порядка числа на `1` расстояния между соседними машинными числами (в пределах постоянного порядка) уменьшатся вдвое. А при уменьшении отрицательного порядка на `1`, наоборот, расстояния между соседними машинными числами уменьшается вдвое. Таким образом, машинные числа на числовой оси распределены не равномерно и тем гуще, чем ближе они к машинному нулю (внутри диапазона мшинного нуля имеется ровно одно машинное число - это сам ноль).

Для определения расстояния между соседними машинными числами в окрестности данного числа с плавающей точкой имеется встроенная функция `eps`. Например,

```julia
julia> eps(1.0)
2.220446049250313e-16

julia> eps(10.0)
1.7763568394002505e-15

julia> eps(0.1)
1.3877787807814457e-17

julia> eps(0.0)
5.0e-324
```

При этом величину `eps(1.0)` обычно называют "машинным эпсилон" (не путать с "машинным нулем").

Машинное эпсилон характеризуется тем, что это наибольшее из всех положительных машинных чисел,
для которых выполняется равенство:

```julia
1.0 + eps(1.0)/2 = 1.0
```

Для обычной (не компьютерной арифметики) такое равенство не возможно. Однако в компьютерной арифметике оно будет иметь место. Происходит это потому, что для сложения двух компьютерных чисел сначала необходимо привести их к одному порядку (большему), а затем уже складывать мантиссы. Но при увеличении порядка числа, его мантиссу приходится сдвигать влево по разрядной сетке, в результате чего в начале мантиссы будут появляться нули, а ее конец будет выходить за разрядную сетку, с потерей части значащих цифр. Поэтому, если двоичные порядки чисел различаются на `53` и более (это соответствует примерно 16 десятичным разрядам: $2^{-53}\approx 10^{-16}$), то тогда уже вся мантисса полностью сместится за пределы разрядной сетки, и при сложении мантисс фактически произойдет поразрядное суммирование с нулями.

## Причины погрешностей арифметики с плавающей точкой

Подведем итог всему сказанному ранее относительно особенностей арифметики с плавающей точкой, выделив следующие причины возможных погрешностей.

- **Потеря точности** - связана с уменьшением числа верных цифр мантиссы. Происходит в результате сложения чисел, сильно различающихся порядков, а также при умножениях и делениях, приводящих к денормализации мантиссы результата операции.

- **Переполнение** - это когда положительный порядок результата арифметических действий превышает максимально возможное значение, т.е. результат по абсолютной величине становится равным `Inf`. Происходит в результате перемножения очень больших чисел, или в результате деления больльшого числа на очень маленькое.

- **Исчезновение порядка** - это когда отрицательный порядок результата арифметических действий по абсолютной величине превышает максимально возможное значение, т.е. результат получается чрезвычайно маленький (и денормализованный). Происходит в результате перемножения очень маленьких чисел, или в результате деления маленького числа на очень большое.

Имеют место соотношения:

```julia
1/0.0 == Inf
1/Inf == 0.0
1/0.0 == Inf
Inf*Inf == Inf
Inf/Inf == NaN
0.0/0.0 == NaN
0.0*Inf == NaN
Inf^0 == 1.0    # !!!
Inf^Inf == Inf
```

где `NaN` - это значение с плавающей точкой, не представляющее никакое число.

Все арифметические операции, имеющие хотя бы один аргумет со значением `NaN`, всегда дают в результате `NaN`.

## Тип Complex

Для работы с комплексными числами в Julia имеется встроенный параметрический тип Complex{T}, где T <: Number  - тип вещественной и мнимой частей.

Примеры записи комплексных чисел

```julia
1+3im
2.0 + 0.5im
1//2+3//2im
```

Для комплексных значений определены, например, все арифметические операции, а также функции abs, angle, real, imag. Многие встроенные математические функции, такие как sin, cos, exp (и другие), также определены и для комплексных значений.