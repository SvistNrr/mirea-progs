# Лекция 6

Элементы вычислительной геметрии (продолжение, начало в лекции 5)

## Задача определения, лежит ли заданная точка плоскости внутри заданного многоугольника

Подчеркнем, что речь идет о произвольном многоугольнике, не оязательно выпуклом.

**Утверждение 1.** Для любой точки плоскости, лежащей вне некоторого многоугольника, сумма всех углов, между векторами с началом в данной точке и с концами в смежных вершинах многоугольника (с учетом знака) равна нулю.

**Утверждение 2.** Для любой точки плоскости, лежащей внутри некоторого многоугольника, сумма всех углов, между векторами с началом в данной точке и с концами в смежных вершинах многоугольника (с учетом знака) равна 360 градусам.

Допустим сначала, что располжение внешней точки относительно многоугольника и сам многоугольник таковы, что любой луч, проведенный из этой точки пересекает границу многоугольника не более двух раз. Если луч пересекает многоугольник только один раз, то это значит, что он проходит через какую-то вершину многоугольника внешним образом. Ясно, что имеется по краней мере две таких вершины, которые условимся называть крайними. Мы сейчас могли бы также не исключать и случай, когда какая-либо сторона многоугольника лежит на луче, в этом случае "крайней" будем считать (для определенности) ближайшую к точке вершину.

В этом случае доказательство утверждения 1 очевидно. Если многоугольник и расположение внешней точки не обладают указанным свойством, тогда надо рассмотреть углы между лучами, проходящими через вершины, у которых обе инцидентные им стороны остаются с одной стороны от луча. Если нарисовать рисунок, до справедливость утверждения 1 тоже станет очевидной.

Аналогично можно доказать и утверждение 2.

**Замечание.** С учетом того, что вычисления будут осуществляться в арифметике с плавающей точкой, может возникнуть проблема сравнения суммы углов с $0$ или с $2\pi$. Однако, поскольку эта сумма не может иметь промежуточных значений между указанными величинами, то сравнивать можно с значением $\pi$: если сумма окажется окажется меньше, то это будет означать, что она равна $0$, а если - больше, то  - что она равна $2pi$.

## Задача построения выпуклой оболочки заданного множества точек плоскости

Задача ставится так. Дан некоторый массив координат точек плоскости. Требуется определить, какие из этих точек являются вершинами наименьшего выпуклого многоугольника, содержащего все остальные точки. Это наименьший многоугольник и называется **выпуклой оболочкой** заданного набора точек плоскости.

Понятие выпуклой оболочки поясняет следующий рисунок ![рисунок 2](lecture_2_6_fig-1.png)

Нарисунке показано, что если в точки "забить гвоздики", и поверх всех гвоздиков надеть хозяйственную резинку, то эта резинка примет форму выпуклой оболочки заданных точек.

Расмотрим несколько популярных алгоритмов построения выпуклой оболочки.

### Алгоритм Джарвиса

![Рисунок 3](lecture_2_6_fig-2.png)

Этапы алгоритма

- В заданном массиве находится самая нижняя точка, обозначим её $P_1$, и выбирается начальное базовое направление $l_1$ (на рисунке вектор этого направления напрвлен по горизонтали врправо). Точка $P_1$ гарантированно войдет в выпуклую оболочку.
  
- Следующая точка, обозначим её $P_2$, которая гарантированно войдет в выпуклую оболочку, будет точка, направление на которую из точки $P_1$ с базовым направлением $\vec l_1$ будет составлять наименьший угол. После выбора этой точки следует выбрать новое базовое направлением $\vec l_2=\overrightarrow{P_1P_2}$.

- Далее каждая $k+1-ая$ точка, добавляемая в выпуклую оболочку, определяется как точка, угол между направлением на которую из $k$-ой точки, и $k$-ым базовым направлением $\vec l_k$ является минимальным.

Алгоритм завершается когда очередная точка выпуклой оболочки не совпадет с точкой $P_1$.

**Оценка сложности.** Сложность алгоритма Джарвиса в наихудшем случае, когда почти все заданные точки войдут в выпуклую оболочку, оценивается как $O(N^2)$, где $N$ - это число всех точек.

Однако часто число точек, вошедших в выпуклую оболочку, много меньше числа всех точек. Если число всех точек выпуклой оболочки можно оценить функцией $O(g(N))$, то то оценка общей сложности алгоритма Джарвиса будет иметь вид $O(N\cdot g(N))$.

Например, если предположить, что N точек более-менее равномерно заполняют некоторую выпуклую область плоскости, то число точек, входящих её в выпуклую оболочку можно оценить как $g(N)=O(\sqrt(N))$.
  
### Алгоритм Грехома

Прежде всего вспомним понятие стека.

В программировании **стеком (stack)** называют абстрактный тип данных, представляющий набор элементов какого-либо типа, организованный по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»). 

При работе со стеком используется протокол, состоящий из действий:

- проверить, является ли стек пустым;

- добавить (положить) в стек новый элемент; об этом говорят еще: поместить элемент на вершину стека;

- снять с вершины стека очередной элемент (возможно только, если стек не пустой);

Конкретная реализация стека может быть разной, например, он может быть реализован на основе динамического массива.

**Алгоритм Грехома** сводится к следующим этапам.

- Сначала надо найти базовую точку $P_0$, и выбираеть базовое направление $\vec l_0$ (точно так же, как это делалось в алгоритме Джарвиса).

- Все остальные точки сортируются по возрастанию угла между вектором $\vec l_0$ и вектором $\overrightarrow{P_0P_k}$ для $k=1,2,...,N$.
  
- Далее в выпуклую оболочку помещаютсяточки $P_1 и P_2$ (они гарантированно в неё входят).
  
- Каждая сдедующая в отсортирванном порядке точка помещается в выпуклую оболочку, но пока временно. Т.е. эта точка помещается на вершину стека, в который вконце-концов должна быть помещена вся выпуклая оболочка, но на следующих шагах алгоритма некоторые точки с вершины этого стека могут быть сняты.

А именно, пусть в стеке уже имеется $k$ точек. Тогда прежде чем на его вершину будут помещена очередная точка, из него сначала должны быть извлечены все точки, наличие котрых делает "текущую оболочку" не выпуклой (под "текущей оболочкой" здесь понимается многоугольник, вершины которого находятся в данный момент в стеке и ещё одна его вершина - это новая точка из отсортированной последовательности точек).

Следующая серия рисунков поясняет работу данного алгоритма

![Рисунок 3](lecture_2_6_fig-3.png)

Так же работу этого алгоритма в динамеке можно посмотреть, например, [здесь](https://habr.com/ru/post/144921/)

**Оценка сложности.**  Оценка сложность алгоритма Грехома определяется оценкой сложности алгоритма сортировки, поэтому можно считатать, что сложность оценивается как $N \log N$

**Указание для программирования.** Реализовать стек проще всего на базе динамическго массива и использовать функции: isempty, push!, pop!.

## Задача вычисления ориентированной площади плоского многоугольника

В данном случае речь идет о произвольном многоугольнике, не обязательно выпуклом.

Задача ставится так: дана последователность точек - вершин произвольного многоугольника (допускаются даже пересечения его сторон), заданная в порядке обхода, например, против часовой стрелке (или по часовой стрелке - это не принципиально). Задание направление обхода означает, что граница многоугольника является ориентированной. Требуется вычислить площадь этого многоугольника. Причем, если ориентация границы положительная (направление обхода против часовой стрелки), то и площадь будет положительной, в противном случае площади приписывается знак минус.

Известно несколько простых методов решения этой задачи.

### Метод трапеций

Следующий рисунок поясняет суть этого метода
![рисунок 4](lecture_2_6_fig-4.png)
Двигаясь по границе многоугольника от вершины к вершине вдоль заданной ориентации границы, надо вычислять площади трапеций одна из боковых сторон которых есть некоторое ребро многоугольникам(см.рисунок), причем периметры этих трапеций надо рассмативать как ориентированные границы, ориентация которых задаётся ориентацией самого многоугольника. Просуммировав полощади трапеций с нужными знаками, найдём полощадь многоугольника. Вычислять площади треугольников удобнее всего с помощью косого произведения, т.е. с помощью написанной нами функции `xdot`.

Пусть, например, $P_k=(x_k, y_k)$ и $P_{k+1$}=(x_{k+1},y_{k+1})$ - две соседние вершины многоугольника. При этом не важно в какой последовательности перечислены вершины многоугольника: по часовой стрелке (как на рисунке) или - против. От этого будет зависеть только знак результата. Если нас интересует именно площадь, то можно просто брать его абсолютную величину.

Тогда площать соответсвующей трапеции будет вычисляться по формуле 

$$
(y_{k}+y_{k+1})(x_{k+1}-x{k})/2
$$

(эта площадь будет иметь знак, игнорировать его нельзя).

### Метод треугольника

Этот метод аналогичен методу трапеций, только вместо трапеций используются треугольники. Суть этого метода поясняется на следующем рисунке
![рисунок 6](lecture_2_6_fig-5.png)

Пусть, например, $P_0=(x_0,y_0) - это координаты некоторой вершины многоугольника, выбранной (произвольным образом) в качестве базовой, и $$P_k=(x_k, y_k)$ и $P_{k+1$}=(x_{k+1},y_{k+1})$ - какие-либо две другие соседние вершины многоугольника. При этом также как и в методе трапеций не важно в какой последовательности перечислены вершины многоугольника: по часовой стрелке (как на рисунке) или - против. От этого также будет зависеть только знак результата.

Тогда площать соответсвующего треугольника может быть вычислена с помощью косого произведения вектров $P_k-P_0$ и $P_{k+1}-P_0$

(эта площадь также будет иметь знак, игнорировать который нельзя).

**Замечание.** Вид формул для вычисления площади трапеции в методе трапеций и - площади треугольника в методе треугольников не зависит от положения начала координат.

### Формула Гаусса

Существует ещё формула Гаусса для площади многоугольника
[формула Гаусса](https://ru.wikipedia.org/wiki/Формула_Площади_Гаусса)

**Замечание.** Для языка Julia имеется пакет [GeometryBasics]( https://juliageometry.github.io/GeometryBasics.jl/dev/), реализующий многие функции вычислительной геометрии.

## Работа с интерактивными блокнотами

### Блокнот Jupyter

Jupyter - это интерактивная вычислительная среда на базе web-браузера.

При этом эту среду можно интегрировать в VS Code, что делает работу в этой среде особенно удобной.

Название Jupyter происходит от начальтых букв языков программирования: Julia, Python, R.

После запуска Jupyter в нем автоматически инициализируется ядро Python. Для того чтобы в блокноте Jupyter можно было запустить ядро Julia в Julia надо установить пакет IJulia.jl (`julia>] add IJulia`) и затем импортировать его (`using IJulia`).

После этого, для запуска блокнота Jupyter из REPL, следует вызвать функцию:

```julia
julia> notebook()
```

Блокнот откроется в браузере, назначенном по умолчанию.

Можно также, если на компьютере установлен Jupyter, запускать его непосредственно. Но для того, чтобы в нём появилось ядро julia всё равно потребуется предварительная установка пакета IJulia.

Кроме того, блокнот Jupyter может быть интегрирован в VS code. Для этого потребуется скачать соответствующее рассширение VS code. Если расширение установлено, то запуск блокнота Jupyter из VS code осуществляется нажатием комбинации клавиш `Shift+Ctrl+P` и выбором соответсвующего пункта меню (котрое ниспадает при нажатии указанной комбинации). Остается только в открывшимся блокноте выбрать ядро julia.

### Блокнот Neptune

Кроме блокнотов Jupyter для языка Julia имеется альтернативная возможность использовать блокноты Neptune, идеология которых существенным образом отличается от идеологии блокнотов Jupyter.

Основное отличие состоит в том, что блокноты Neptune, в отличие от блокнотов Jupyter, отсутствуют скрытое внутреннее состояние, определяемое значениями ранее определенных переменных. Так если в блокте Neptune в некоторой ячейке определена (инициализирована) некоторая переменная, то в других ячейках этой переменной не получится присвоить другое значение (такая попытка приведет к сообщению об ошибке). А если в исходной ячейке значение этой переменной заменить на другое, то этоавтоматически приведет к перевычислению всех остальных ячеек, в которых эта переменная используется. В блокнотах Jupyter в этом отношении может возникнуть полная путаница (при неаккуратной работе).

Для знакомства с Neptune потребуется, прежде всего, установить импортировать этот пакет:

```julia
julia>] add Neptune
julia> using Neptune
```

Далее, для запуска Neptune потребуется выполнить команду:

```julia
julia> Neptune.run()
```

В результате в браузере по умолчанию откроется окно для работы с блокнотами Neptune.

При этом, чтобы вернуться к работе с REPL, понадобится в окне REPL нажать комбинацию клавишь Ctrl+C.

**В отличие от Jupyter, блокноты Neptune сохраняются в файлах с расширением .jl.

Блокноты Neptune состоят из ячеек, аналогичных ячейкам Jupyter, в которые можно помещать программный код или текст в формате Markdown.

**Замечание.** Если при работе в Neptune в тело функции вставлять `println`, обычно это требуется при отладке, то вывод на печать будет происходить не в блокнот, а в REPL. В блокнот выводится только возвращаемое функцией значение.

## Графический пакет Plots.jl

Для построения графиков имеется в языке Julia  имеется пакет [Plots](http://docs.juliaplots.org/latest/tutorial/).

После того как этот пакет будет установлен (`julia>] add Plots`) и импортирован (`using Plots`), можно будет выбрать ту или иную графическую библиотеку (`backend`). Для этого надо выполнить одну из следующих функций (из этого пакета): `pyplot()`, `gr()`, `plotly` и др. (или использовать библиотеку, заданную по умолчанию).

Функция `pyplot()` актуализирует популярную питоновскую библиотеку `matplotlib`, функция `gr()` - другую популярную графическую библиотеку `GR` (используется по умолчанию), функция `plotly()` - одноимённую графическую библиотеку языка `Javascript`. Но не зависимо от того, какой `backend` подключен, пакет `Plots` обеспечивает унифицированный интерфейс к функциям всех перечисленных библиотек, так что на программный код `julia` факт использования той или иной графической библиотеки влияния не оказывает.

В принципе, имеется еще возможность использовать библиотеку `matplotlib`, с привычным кому-то по опыту программирования в `Python` интерфейсом, но для этого придётся уже использовать другой пакет - [`PyPlot.jl`](https://github.com/JuliaPy/PyPlot.jl/blob/master/README.md), докумментация к пакету имеется в [pyplotjl.pdf](https://buildmedia.readthedocs.org/media/pdf/pyplotjl/latest/pyplotjl.pdf).

Для построения ломаной линии в пакете  `Plots` имеется функции `plot` и `plot!`. Первая из них используется для создания графического объекта (графика) - либо пустого, либо содержащего только одну ломаную линию. Например,

```julia
p=plot() 
# создан пустой графический объект p, к которому можно будет добавлять другие графики

xdata = 0:9, ydata = rand(10)
p=plot(xdata, ydata)
# p - графический объект, содержащий ломаную линию с 10 узловыми точками
```

Чтобы узнать тип переменной `p`, можно сделать следующее.

```julia
typeof(p)
Plots.Plot{Plots.GRBackend}
```

Теперь, чтобы к созданному тем или иным способом объекту `p` можно будет добавить еще одну или несколько ломаных линий. Для этого нужно уже будет воспользоваться функцией `plot!`.

Например, следующий код построит целое семейство кривых.

```julia
p=plot()
for _ in 1:5
    plot(p, 0:9, rand(10))
end
display(p) 
```

**Замечание 1.** Для того, чтобы отобразился сформированный в объекие p график, необходимо вызвать функцию display(p).

При выполнении команды типа plot(x,y) непосредственно в REPL, при условии что эта команда была последней (или единственной), функция display будет вызывана автоматически, получив в качестве аргумента ссылку на обект с графиком, возвращаемую в данном случае функцией plot.

Однако если имеется цикл, в котором вызывалась функция plot, то графики отображены не будут (автоматически), поскольку значение цикла есть nothing. Поэтому в этом слусае необходим явный вызов функции display.

**Замечание 2.** Если в программе иммется только одно окно с графиком, то это окно всегда будет **текшим** окном (графиком). И в этом случае создавать переменную p необходимости нет, программа будет работать с текущим окном, например, прежний код мог бы быть записан еще и следующим образом.

```julia
plot()
for _ in 1:5
    plot(0:9, rand(10))
end
display() 
```

Результат получится в точности тот же.

Аналогичная ситуация может возникнуть при помещении процедуры построения графика в функцию.

Например, если имеется следующая функция

```julia

function rand_curve(n)
    x = rand(n)
    y = rand(n)
    plot(x,y)
end
```

то в результате её вызова

```julia
julia> rand_curve(100)
```

график так же будет отображаться автоматически (потому что функция вернула значение, возвращаемое функцией plot).

Но если функцию определить чуть иначе следующим образом

```julia
function rand_curve(n)
    x = 0:n-1
    y = rand(n)
    plot(x,y)
    return y
end
```

то её вызов

```julia
julia> rand_curve(100)
```

уже не приведеь к отображению графика, потому что в этом случае будет отсутствовать ссылка на объект с графиком.

Ситуацию можно было бы поправить, например, так

```julia
function rand_curve(n)
    x = 0:n-1
    y = rand(n)
    p = plot(x,y)
    return p, y
end
```

Теперь, наша функция уже будет возвращать ссылку на объект с графиком, который можно будет отобразить следующим образом.

```julia
julia> p,y = rand_curve(100)
julia> display(p)
```

Или можно было бы сделать так

```julia
function rand_curve(n)
    x = 0:n-1
    y = rand(n)
    plot(x,y)
    display()
    return y
end
```

Но в общем случае такой вариант представляется не очень хорошим решением. Лучше когда функции только что-либо вычисляют, а соответствующие графики уже можно будет будет построить на самом верхнем уровне, т.е. непосредственно в REPL.

Во всех приведенных выше примерах свойства линий графика устанавливаются автоматически (значениями, принятыми по умолчанию), причем цвета графиков автоматически задаются так, чтобы разные линии различались по цвету.

Для того, чтобы свойства графика (`Series Attributes`): цвет линии (`linecolor`), толщина линии (`linewidth`), стиль линии (`linestyle`), размер узловых точек (`markersize`), их цвет (`markercolor`), их форма (`markershape`) и т.п. можно было задавать требуемым образом, у функций `plot`, `plot!`, `skatter`, `skatter!` предусмотрены соответствующие именованные аргументы.

Так, атрибуты линии графика `linecolor` и `markercolor` задается символьными значениями, такими как `:red` (красный), `:green` (зеленый), `:blue (голубой)`, `:violent (фиолетовый)`, `:yellow` (желтый) `:grey` (серый), `:white` (белый), `:black` (чёрный) и др., вот полный перечень наименований в системе цветов [X11](https://en.wikipedia.org/wiki/X11_color_names). Значение цвета также можно задавать с помощью конструктора цвета `RGB(r, g, b)`, где параметры `r`,`g`,`b` со значеями из отрезка $[0;1]$ опеределяют интенсивность соответсвующих составляющих цвета.

Атрибут `linestyle` - определяет стиль линии, он задается символьным значением из числа:  `:auto`, `:solid` (сплошная линия), `:dash` (пунктир), `:dot` (точки), `:dashdot` (штрих-пунктир), `:dashdotdot` (двойной штрих-пунктир).

Атрибут `markershape` - определяет форму маркера, он задается символьным значением из числа: `:circle`, `:cross`, `:xcross` и др.

Aтрибут `seriestype` - определяет тип графика, он задается символьным значением из числа: `:line` (строится обычная ломаная),  `:scatter` (строятся только узловые точки графика, не соединенные линиями), `:shape` (строится многоугольник с заливкой цветом) и др. (предусмотрены ещё многие другие типы графиков).

Например, чтобы построить график многоугольника, залитого цветом, координаты вершин котрого содержатся в двух числовых массивах `xdata`, `ydata`, можно воспользоваться значением `:shape` фтрибута `seriestype`:

```julia
plot(xdata, ydata; seriestype = :shape, color = RGB(1,0,0)) # RGB(1,0,0) - это тоже самое, что и :red (красный)
```

Также иожно пользоваться конструктором специального типа `Shape`:

```julia
plot(Shape(xdata, ydata); color = :red)
```

Особенно удобно пользоватся этим конструктором, если координаты вершин многоугольника заданы не двумя отдельными числовыми массивами, а одним массивом кортежей пар вещественных чисел: `verdata::Vector{Tuple{Real, Real}}`:

```julia
plot(Shape(verdata); сolor = RGB(0,1,0))
```

**Замечание 3.** Если имеются числовые массивы `xdata`, `ydata`, то построить из них массив кортежей можно с помощью ыстроенной функции `zip` (возвращающей генератор соответствующих кортежей): `verdata=[p for p in zip(xdata, ydata)]`.

Aтрибут `aspect_ratio` (или просто `ratio`) - определяет масштабы на координатных осях, он задается символьными значениями: `:auto` (масштабы выбираются автоматически), `:equal` (масштабы устанавливаются одинаковыми) и др.

Атрибуты `linewidth`, `markersize` - задаются числовыми значениям (нужные величины можно подобрать эксперментально).

Кроме функций `plot` и `plot!`  в пакете имеются ещё функции `scatter` и, соответственно, `scatter!`. Вместо двух последних можно использовать также функции `plot` и `plot!`, вызываемые с нужным значением соответсвующего  именованного параметра `seriestype = :scatter`, имеющегося у них.

Более подробную информацию о функциях пакета Plots можно найти [здесь](http://docs.juliaplots.org/latest/tutorial/).
