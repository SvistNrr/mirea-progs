# Лекция 7. Генерация комбинаторных объектов

- Размещения `n` элементов по `k` с повторениями.
- Перестановки `n` элементов.
- Все подмножества `n`-элементного множества.
- `k`-элементные подмножества `n`-элементного множества.
- Разбиения натурального числа на положительные слагаемые.
- Итераторы для перебора комбинаторных объектов.

## 1. Генерация всех размещений с повторениями из n элементов {1,2,...,n} по k

Требуется перечислить все возможные последовательности длины k, элементы которых принадлежат `{1,2,...,n}`.
Идея состоит в том, чтобы перечисоить их в **лексикографическом** порядке.

Говорят, что строки (кортежи, вектора) $s_1,s_2,s_3...$ перечислены в лексикографическом порядке, если $\forall i \ s_i<s_{i+1}$, что означает, что либо $s_{i}$ короче $s_{i+1}$ и $s_i$ совпадает с началом $s_{i+1}$, либо первые $m \ (m \ge 0)$ элементов в $s_i$ и $s_{i+1}$ совпадают, и $s_{i}[m+1] < s_{i+1}[m+1]$.

Таким образом, перечислить все вектора длины k требуется в таком порядке: 

[1,...,1,1]

[1,...,1,2]

...........

[1,...,1,n]

[1,...,2,1]

[1,...,2,2]

...........

[1,...,2,n]

[1,...,3,1]

...........

[1,...,3,n]

...........

[n,...,n,n]

В частности, при n=2 и k=3, имеем 2^3=8 размещений с повторениями:

[1, 1, 1]

[1, 1, 2]

[1, 2, 1]

[1, 2, 2]

[2, 1, 1]

[2, 1, 2]

[2, 2, 1]

[2, 2, 2]

Напишем функцию, котрая получив на вход какой-либо вектор длины k, с элементами из {1,2,...,n}, возвращает "следующий" вектор.

```julia
function next_repit_plasement!(p::Vector{T}, n::T) where T<:Integer
    i = findlast(x->(x<n), p) # используется встроенная функция высшего порядка
    if isnothing(i)
        # p - это самый последний вектор в последовательности, следующего уже нет
        return nothing
    end
    p[i] += 1
    p[i+1:end] .= 1 # - устанавливаются минимально-возможные значения
    return p
end
```

Протестировать эту функцию можно, например, так:

```julia
n = 2; k = 3
p = ones(Int,k)
while !isnothing(p)
    global p = next_repit_plasement!(p,n)
    println(p)
end
```

**Замечание**. Вместо множества $\{1,2,...,n\}$, можно было бы рассмотривать множество $\{0,1,2,...,n-1\}$.
Тогда все размещения элементов этого множества по $k$ элементов суть $n$-ичные записи чисел $\{0,1,...,n^k-1\}$ длины $k$. 

Таким образом, все размещения элементов множества $\{0,1,2,...,n-1\}$ по $k$ элементов, могут быть перечислены с использованием встроенной функции `digits`: 

```julia
for i in 0:n^k-1
    digits(Int, i; base=n, pad=k) |> println
end
```

**Замечание.** Функция `digits` преобразует целое число `i` в вектор, составленный из последовательности цифр этого числа (это значения типа `Int`) в `n`-ичной системе счисления. Возвращаемая последовательность цифр (в виде вектора) начнается с цифры младшего разряда, причем длина этой последовательнотси больше или равна `k` (длина меньше `k` получиться не может, т.к. при необходимости недостающие цифры старших разрядов автоматически обнуляются).

С учетом этого получается, что в записанном цикле выводимые размещения будут следовать в **антилексикографическом** порядке.

## 2. Генерация вcех перестановок 1,2,...,n

Как известо существует ровно $n!$ различных перестановок n элементов.

Эти перестановки также можно перечислить в лексикографическом порядке:

[1, 2, ..., n-1, n]

...................

[n, n-1, ..., 2, 1]

В частности, при n = 4 имеем 4!=24 перестановки:

[1, 2, 3, 4]

[1, 2, 4, 3]

[1, 3, 2, 4]

[1, 3, 4, 2]

[1, 4, 2, 3]

[1, 4, 3, 2]

[2, 1, 3, 4]

[2, 1, 4, 3]

[2, 3, 1, 4]

[2, 3, 4, 1]

[2, 4, 1, 3]

[2, 4, 3, 1]

[3, 1, 2, 4]

[3, 1, 4, 2]

[3, 2, 1, 4]

[3, 2, 4, 1]

[3, 4, 1, 2]

[3, 4, 2, 1]

[4, 1, 2, 3]

[4, 1, 3, 2]

[4, 2, 1, 3]

[4, 2, 3, 1]

[4, 3, 1, 2]

[4, 3, 2, 1]

Таким образом, для того, чтобы из заданной перестановки получить "следующую", требуется:

- перемещаясь из конца перестановки p к её началу, найти ближайшую позицию k, на которой k+1-ый элемент больше k-го. Причем, если такой позиции не окажется (в этом случае будем считать k=0), то это означает, что данная перестановка является "последней". Т.е., если только перестановка p не является "последней", имеем 
`p[k]<p[k+1] > p[k+2]>...>p[n]`
- затем, в "хвосте" `p[k+1:n]` надо найти позицию `i`, на которой стоит наименьшее значение, большее `p[k]`;
- затем, элементы  `p[k]` и `p[i]` требуется поменять местами, а все элементы `p[i+1]...p[n]` переставить в обратном порядке.

Соответствующий программный код, может выглядеть следующим образом.

```julia
function next_permute!(p::AbstractVector)
    n = length(p)
    k = 0 # или firstindex(p)-1
    for i in reverse(1:n-1) # или reverse(firstindex(p):lastindex(p)-1)
        if p[i] < p[i+1]
            k=i
            break
        end
    end
    k == firstindex(p)-1 &&  return nothing # т.е. p[begin]>p[begin+1]>...>p[end]
 
    #УТВ: p[k]<p[k+1] > p[k+2]>...>p[end]
    i=k+1
    while i<n && p[i+1]>p[k] # i < lastindex(p) && p[i+1] > p[k]
        i += 1
    end
    #УТВ: p[i] - наименьшее из всех p[k+1:end], большее p[k]
    p[k], p[i] = p[i], p[k]
    #УТВ: по-прежнему p[k+1]>...>p[end]
    reverse!(@view p[k+1:end])
    return p
end

#Тестирование:
p=[1,2,3,4]
while !isnothing(p)
    println(p)
    global p
    p = next_permute!(p)
    println(p)
end
```

## 3. Генерация всех всех подмножеств n-элементного множества {1,2,...,n}

**Индикатором** (индикаторной функцией) некоторого множества $B$ называется функция, определенная на соответствующем **универсальном** для данной задачи множестве $A$ ($B \subset A$) следующим образом:

$$
I_B(x) =
\begin{cases}
1, & \text{если } x \in B\\
0, & \text{если } x \notin B
\end{cases}
$$

Здесь значения `1`, `0` можно интерпретировать как `true` и `false`, соответственно.

В частности, если "универсальное" множество $A$ представлено вектором $[1,2,...,n]$, то индикаторную функцию $I_B$ любого его подмножества $B$, можно представить одноименным массивом булевского типа (`Bool`): `I_B[i] = true`, если `A[i] in B`, то , и `I_B[i] = false` - в противном случае.

Таким образом, задача перечисления всех подмножеств `B` заданного множества `A` фактически сводится к перечислению их индикаторов.

Индикаторы всех подмножеств множества $A=\{1,2,...,n\}$ будем перечислять в лексикографическом порядке:

[0, 0, ..., 0, 0]

[0, 0, ..., 0, 1]

.................

[1, 1, ..., 1, 0]

[1, 1, ..., 1, 1]

Рассмотрим два способа перечеслиния этих индикаторов.

### 3.1. Первый способ - на основе генерации двоичных кодов чисел 0, 1, ..., 2^n-1

```julia
indicator(i::Integer, n::Integer) = digits(Bool, i; base=2, pad=n) # reverse(digits(Bool, i; base=2, pad=n))
```

**Замечание.** Функция `digits` возвращает последовательность цифр в обратном порядке, поэтому, чтобы получать с её помощью соответствующие вектора именно в лексикографическом порядке, их нужно было бы переворачивать. Однако этого делать не обязательно, важно лишь, чтобы были перечислены все индикаторы.

### 3.2. Второй способ - на основе непосредственной генерации последовательности индикаторов в лексикографическом порядке

Процедура состоит в следующем:

- надо найти индекс самого последнего нулевогоэлемента масства (индикатора); если такогого не найдется, то данный вектор есть индикатор всего множества и, следовательн, является "последним";

- затем этому элементу следует присвоить значение 1, а все последующие - обнулить.

Соответствующий программный код может быть записан следующим образом.

```julia
function next_indicator!(indicator::AbstractVector{Bool})
    i = findlast(x->(x==0), indicator)
    isnothing(i) && return nothing
    indicator[i] = 1
    indicator[i+1:end] .= 0
    return indicator 
end
```

Протестировать эту функцию можно так:

```julia
n=5; A=1:n
indicator = zeros(Bool, n)
while !isnothing(indicator)
    global indic
    A[findall(indicator)] |> println
    indicator = next_indicator!(indicator)
    println(indicator)
end
```

## 4. Генерация всех k-элементных подмножеств n-элементного множества {1, 2, ..., n}

Это задачу можно было бы решать на основе перечисления всех подмножеств и выбора из них только $k$-элементных, однако это было бы не эффективно, поскольку число всех подмножеств $n$-элементного множества есть равно $2^n$.

Поэтому будем перечислять эти индикаторы в лексикографическом порядке непосредственно:

[0, ..., 0, 1, ..., 1] - все k единиц - в самом конце

......................

[1, ..., 1, 0, ..., 0] - все k единиц - в самом начле

Например, при $n=6, k=3$, имееем всего $C_n^k=\frac{6!}{3!\cdot 3!}=20$ подмножеств:

[0, 0, 0, 1, 1, 1]

[0, 0, 1, 0, 1, 1]

[0, 0, 1, 1, 0, 1]

[0, 0, 1, 1, 1, 0]

[0, 1, 0, 0, 1, 1]

[0, 1, 0, 1, 0, 1]

[0, 1, 0, 1, 1, 0]

[0, 1, 1, 0, 0, 1]

[0, 1, 1, 0, 1, 0]

[0, 1, 1, 1, 0, 0]

[1, 0, 0, 0, 1, 1]

[1, 0, 0, 1, 0, 1]

[1, 0, 0, 1, 1, 0]

[1, 0, 1, 0, 0, 1]

[1, 0, 1, 0, 1, 0]

[1, 0, 1, 1, 0, 0]

[1, 1, 0, 0, 0, 1]

[1, 1, 0, 0, 1, 0]

[1, 1, 0, 1, 0, 0]

[1, 1, 1, 0, 0, 0]

Таким образом, процедура состоит в следующем:
- двигаясь с конца массива к его началу ищем первый элемент, который можно увеличить (первый элемент, равный 0, за которым стоит 1);
- увеличиваем его, т.е. заменяем 1, а остальные элементы в "хвосте" определяем "минимально возможным" способом, т.е. все содержашиеся в нем единицы "перемещаем" в саымый конец.

```julia
function next_indicator!(indicator::AbstractVector{Bool}, k)
    # в indicator - ровно k единц, остальные - нули, но это не проверяется! (фактически k - не используется)
    i=lastindex(indicator)
    while indicator[i]==0
        i-=1
    end
    #УТВ: indic[i]==1 и все справа - нули
    m=0; 
    while i >= firstindex(indicator) && indicator[i]==1 
        m+=1
        i-=1
    end
    if i < firstindex(indicator)
        return nothing
    end
    #УТВ: indicator[i]==0 и справа m>0 единиц, причем indicator[i+1]==1
    indicator[i]=1
    indicator[i+1:i+m-1] .= 0
    indicator[i+m:end] .= 1
    return indicator 
end
```

Протестировать эту функцию можно, например, следующим образом.

```julia
n=6; k=3; A=1:n
indicator = [zeros(Bool,n-k); ones(Bool,k)]
A[findall(indicator)] |> println
for !isnothing(indicator)
    global indicator = next_indicator!(indicator, k)
    A[findall(indicator)] |> println
end
```

## 5. Генерация всех разбиений натурального числа на положительные слагаемые

Дано натуральное (неотрицательное целое) число n. Тпебуется найти все возможные представления (разбиения) этого числа в виде суммы натуральных чисел. При этом разбиения, отличающиеся только порядком слагаемых, не будем считать разными.

Рассмотрим пример при n=5:

 `5 = 1+1+1+1+1 = 2+1+1+1+0 = 2+2+1+0+0 = 3+1+1+0+0 = 3+2+0+0+0 = 4+1+0+0+0 = 5+0+0+0+0`


Идея процедуры перечисления всех разбиений состоит в том, чтобы перечислить их в лексикографическом порядке. При этом число ненулевых элементов каждого последующего разбиения не будет превосходить числа ненулевых элементов данного разбиения.

Для этого все ненулевые слагаемые, входящие в какое-либо разбиение, будем хранить в векторе `s`, при этом: 

- `n = s[1]+...+s[k]`, где `k=length(s)` - число положительных слагаемых в разбиении;
- дополнительно потребуем чтобы `s[i-1]>=s[i]` при всех `i in (2,3,...,k)` (чтобы исключать разбиения, отличающиеся лишь порядком элементов).

Тогда, чтобы при выполнении этих двух условий можно было бы увеличить `s[i]`, не меняя значений `s[1],...,s[i-1]`, 
требуется, чтобы
- `s[i-1] > s[i]` или `i = 1`
- `i < k` (что бы иметь возможность уменьшения последуюших элементов, для сохранения требуемого баланса).

При увеличении значения `s[i]` на `1`, все последующие элементы надо брать минимально возможными (в лесикографическом смысле).

```julia
"""
Должно быть length(s) == n, где n - заданное число
    
    s[i-1]>=s[i] for all i in (2,3,...,k), 

где k - число элементов заданного разбиения, представленного вектором s, т.е. число ненулевых элементов в начале вектора s.
"""
function next_split!(s::AbstractVector{Integer}, k)
    k == 1 && return nothing
    i = k-1 # - это потому что s[k] увеличивать нельзя
    while i > 1 && s[i-1]==s[i]
        i -= 1
    end
    #УТВ: i == 1 или i - это наименьший индекс: s[i-1] > s[i] и i < k
    s[i] += 1
    #Теперь требуется s[i+1]... - уменьшить минимально-возможным способом (в лексикографическом смысле) 
    r = sum(@view s[i+1:k])
    k = i+r-1 # - это с учетом s[i] += 1
    s[i+1:n-k] .= 1
    return s, k
end

# Тестирование:
n=5; s=ones(Int, n); k=n
while !isnothing(s)
    println(s[1:k])
    global s
    s, k = next_split!(s, k)
    println(s)
end
```

## 6. Специальные пользовательские типы и итераторы для генерации рассматриваемых комбинаторных объектов

Мы разработали следующие функции

`next_rep_plasement(c::Vector, n)` - для генерации размещений с повторениями
`next_permute(p::AbstractVector)`  - для генерации перестановок
`next_indicator(indicator::AbstractVector{Bool})` - для генерации всех подмножеств
`next_indicator(indicator::AbstractVector{Bool}, k)` - для генерации k-элементных подмножеств
`next_split(s::AbstractVector{Integer}, k)` - для генерации разбиений

Все эти функции предполагается использовать так: сначала создается некоторый начальный комбинаторный объект, а затем в цикле, с помощью какой-либо из перечисленных функций, получаются все остальные комбинаторные объекты до тех пор, пока перечисление этих объектов не будет исчерпано.

Однако такие перечисления объектов можно организовывать с помощью итераторов, что делает код более "чистым". Но для этого для каждого класса комбинаторных объетов понадобится спроектировать соответствующий пользовательский тип, для которго также потребуется определить функцию `iterate`. 

При этом, поскольку каждый из рассматриваемых нами комбинаторных объектов представляется просто некоторым числовым вектором, которые мы собираемся "обернуть" в соответствующую структуру, все итераторы для таких типов не будут различаться, то представляется целесообразным сначала определить следующий абстрактный тип. От которого затем будут наследовать все интересующие нас конкретные типы.

```julia
abstract type AbstractCombinObject
    # value::Vector{Int} - это поле предполагается у всех конкретных типов, наследующих от данного типа
end

Base.iterate(obj::AbstractCombinObject) = (get(obj), nothing)
Base.iterate(obj::AbstractCombinObject, state) = 
    if isnothing(next!(obj)) # == false
        nothing
    else
        (get(obj), nothing)
    end
```

В этом определении абстрактного типа предполагается, что в каждом производном от него конкретном типе будет наличествовать:

- специальное поле, в котором будет храниться значение, определяющее очередной комбинаторный объект, и функция `get`, возвращающее значение этого объекта;
  
- функция `next!`, получающая на вход некоторый комбинаторный объект соответствующего конкретного типа и изменяющая его так, что бы содержащееся в нем значение стало "следущим".

Далее будут определены требуемые производные конкретные типы.

### 6.1. Размещения с повторениями

```julia
struct RepitPlacement{N,K} <: AbstractCombinObject
    value::Vector{Int}
end

RepitPlacement{N,K}() where {N, K} = RepitPlacement{N,K}(ones(Int, K))
Base.get(p::RepitPlacement) = p.value
next!(p::RepitPlacement{N,K}) where {N, K} = next_repit_plasement!(p.value, N)

# Тестирование:
for a in RepitPlasement{2,3}() 
    println(a)
end
# такая запись стала возможной благодаря определению функции iterate(::AbstractCombinObject)
```

## 6.2. Перестановки

```julia
struct Permute{N} <: AbstractCombinObject
    value:Vector{Int}
end

Permute{N}() where N = Permute{N}(collect(1:N))
Base.get(obj::Permute) = obj.value
next!(permute::Permute) = next_permute!(permute.value)

# Тест:
for p in Permute{4}()
    println(p)
end
```

### 6.3. Все подмножества n-элементного множества

```julia
struct Subset{M} <: AbstractCombinObject # M::Union{Set, Vector, Tuple}
    indicator::Vector{Bool}
end

Subset{M}() where M = Subset{M}(zeros(Bool, length(M)))
Base.get(sub::Subsets{M}) where M = collect(M)[findall(sub.indicator)]

next!(sub::Subset{M}) where M = next_indicator!(sub.indicator) 
#=
Можно было бы возвращать:
    Subset{collect(M)[next_indicator!(sub.indicator)]}()
но поскольку использование функции next!  напрямую не предполагается, то преобразование индикатора в соответствующее подмножество тут не требуется
=#

#Тест:
for sub in Subset{1:4}()
    println(sub)
end
```

### 6.4. k-элементные подмоножества n-элементного множества

```julia
struct KSubset{M,K} <: AbstractCombinObject
    indicator::Vector{Bool}
end

KSubset{M, K}() where{M, K} = KSubset{M,K}([zeros(Bool, length(M)-K); ones(Bool, K)])
Base.get(sub::Subsets{M}) where M = collect(M)[findall(sub.indicator)]
next!(sub::KSubset{M, K}) where{M, K} = next_indicator!(sub.indicator, K) 

#=
параметр M - это или некоторое множество (Set) или диапазон (<:AbstractRange), представляющий множество, подмножества коророго перечисляются

параметр K - это число элементов в перечисляемых подмножествах
=#

#Тест:
for sub in KSubset{1:6, 3}()
    sub |> println
end
```

### 6.5. Разбиения

```julia
struct NSplit{N} <: AbstractCombinObject
    value::Vector{Int}
    num_terms::Int # число слагаемых (это число мы обозначали - k)
end

NSplit{N}() where N = NumSplit{N}(collect(1:N), N)
Base.get(nsplit::NSplit) = nsplit.value[begin:nsplit.num_terms]
next!(nsplit::NSplit) = next_solit!(nsplit.value, nsplit.num_terms)

# Тест:
for s in NSplit{5}()
    println(s)
end
```