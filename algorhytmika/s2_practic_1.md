
# Практическое занятие 1

## Некоторые важные встроенные функциии языка Julia

1. C помощью встроенной помощи (help?>) изучить назначение и способы использования следующих встроенных функций julia:

- zeros, ones, fill, rand
- size, length
- collect
- Array, Vector, Matrix
- similar
- eltype
- copy, deepcopy

2. C помощью встроенной помощи (help?>) изучить назначение и способы использования следующих встроенных функций julia:

- findall, findfirst, findlast
- filter

Самостоятельно реализовать все эти функции на языке Julia

3. C помощью встроенной помощи (help?>) изучить назначение и способы использования следующих встроенных функций julia:

- issorted
- sort!(a), sort(a)
- sortperm!(a), sortperm(a)

Самостоятельно реализовать функцию issorted на языке Julia.

## Сортирвка методом "пузырька"

По аналогии со встроенными функциями сортировки реализовать следующие 4 вида функций сортировки на базе агоритма сортировки методом "пузырька".

```julia
function bubblesort!(a)
    n = length(a)
    for k in 1:n-1
        is_sorted = true
        for i in 1:n-k
            if a[i]>a[i+1]
                a[i], a[i+1] = a[i+1], a[i]
                is_sorted = false
            end
        end
        if is_sorted
            break
        end
    end
    return a
end

bubblesort(a) = bubblesort!(deepcopy(a))

function bubblesortperm!(a)
    n = length(a)
    indexes = collect(1:n)
    for k in 1:n-1
        is_sorted = true
        for i in 1:n-k
            if a[i] > a[i+1]
                a[i], a[i+1] = a[i+1], a[i]
                indexes[i], indexes[i+1] = indexes[i+1], indexes[i]
                is_sorted = false
            end
        end
        if is_sorted
            break
        end
    end
    return indexes
end
bubblesortperm(a) = bubblesortperm!(deepcopy(a))

```

## Массивы в Julia с произвольным способом индексации

Индексация стандартных массивов в Julia  начинается с 1 (в отличие от языка Python или С/C++, где индексация начинается с 0). Такое решение разработчики языка приняли потому, что язык Julia в первую очередь ориентирован на математические вычисления, а в математике принято нумерацию эементов векторов, строк и столбцов матриц начинать с единицы. Однако в Julia имеется возможность определять массивы с произвольными границами индексов, это  массивы типа OffsetArray. Данный тип определен в отдельном пакете OffsetArrays.jl (требующий отдельной установки: pkg> add OffsetArrays).

Например, если имеется обычный массив

```julia
A = [10, 20, 30,40, 50]
```

то превратить его в массив с границами индексов -2:2 можно следующим образом

```julia
using OffsetArrays
A2 = OffsetArray(A, -2:2)
```

Тогда

```julia
A2[-2]  #- это 10
A2[-1]  #- это 20
A2[0]   #- это 30
A2[1]   #- это 40
A2[2]   #- это 50
```

Аналогично можно задать требуемые диапазоны индексов строк и столбцов матрицы (в этом случаее в конструктор OffsetArray потребовалось бы передать уже не один, а два диапазона индексов).

## Способ программирования в Julia без привязки к способу индексации

Если мы ходим иметь работающий код, который не будет приязан к тому, с какого значения индекса начинается индексация массива, то следует пользоваться специальными встроенными функциями: first, firstindex, last, lastindex, nextindex и специальными зарезервированными словами begin, end, которые в контексте индексного выражения обозначают первый и последний индекс массива, соответственно. Например:

```julia
function bubblesort!(a)
    n = length(a)
    for k in 1:n-1
        is_sorted = true
        for i in firstindex(a):lastindex(a)-k
            if a[i] > a[i+1]
                a[i], a[i+1] = a[i+1], a[i]
                is_sorted = false
            end
        end
        if is_sorted
            break
        end
    end
    return a
end
```

## Срезы массивов

Любой массив имеет какое-то число измерений (индексов), dims(A) - встроенная функция, возвращающая число измерений массива A. В частности, если dims(A)==1, то такой массив мы называем вектором, если dims(A)==2, то - матрицей. Всё сказанное в этом параграфе относится к массивам любого числа измерений, но для определенности будем считать, что dims(A)==2.

Срезом массива называют массив, состоящий из элементов данного массива, и получаемый из данного массива с помощью указания соответствующих диапазонов индексов, и/или векторных индексов. Более подробно рассмотрим это на конкретном примере.

Пусть, например,

```julia
A = [10 20 30 40 50
     60 70 80 90 95
     15 25 35 45 55
     65 75 85 96 97]
```

Тогда, например,

```julia
    A[2,3] # - это число 70 
    A[2,3] = 0 # - число 70 заменяется значением 0
```

Выражение A[2,3] можно рассматривать как пример простейшего среза, выделяющего из массива один единственный элемент. Но возможны и срезы, состоящие из многих элементов массива. Рассмотрим некоторые другие примеры срезов массива A:

```julia
A[[1,3],[2,4,5,2]] # - это срез, представляющий собой массив, составленный из элементов массива `A`:

[ A[1,2] A[1,4] A[1,5] A[1,2]
  A[1,2] A[1,4] A[1,5] A[1,2] ]
```

(если строки матрицы записаны одна под другой, то в записи матрицы ставить разделитель строк ";" не обязательно)

Как видим, срез может включать и повторяющиеся элементы исходного массива.

Срез формируется путем копирования элементов данного массива в новую область памяти.

**Задача.** Написать функцию, формирующую срез заданной матрицы по заданным наборам индексов - имеется ввиду без использования конструкции A[I,J], где I,J - два заданных набора индексов (в примере выше, например, I=[1,2], J=[2,4,5,2]).

Решение.

```julia
function slice(A::Matrix,I::Vectot{Int},J::Vector{Int})
    B=Matrix{eltype(A)}(undef,length(I),length(J))
    for i in I
        for j in J
            B[i,j]=A[I[i],J[j]]
        end
    end
    return B
end
```

**Замечание 1.** Встроенная функция eltype(A) возвращает тип элементов массива A (вязыке Julia скалярные значения совместимы с массивами размера "1 на 1", поэтому данную функцию можно применять не только к маасивам, но и к скалярам). Конструктор Matrix{Type} - это синоним Array{Type,2} (Type - это имя какого-либо типа), также как и Vector{Type} - это синоним Array{Type,1}. Запись Matrix{eltype(A)}(undef,length(I),length(J)) - означает, что вызывается конструктор Matrix{Type} со своими фактическими аргументами. При формировании числовых массивов первый аргумент всегда имеет значение undef, что означает, что элементы массива не инициализируются (их значения являются, как принято говорить, просто "информационным мусором"). Два последних аргумента - определяют размер создаваемого массива; допускается передавать размеры массива также в виде одного кортежа.

**Замечание .** Иногда, когда имеется некоторый массив A и требуется сформировать неинициализированный массив B того же типа и размера, то вместо B=Array{eltype(A),ndims(A)}(undef,size(A)) можно воспользоваться специальной встроенной функцией B=similar(A).

Использовать для той же цели функцию zeros (или ей подобную, например, ones) не целесообразно, поскольку операция инициализации массива - не "бесплатная". Однако если требуется именно инициализация массива, то наряду с функциями zeros и ones имеется встроенная функция fill, обеспечивающая инициализациию всех элементов массива каким-либо заданным значением, напрример: fill(value, size), где value - заданное значение, size - кортеж, содержащий размеры создаваемого массива. При этом тип массива будет совпадать с типом значения value; допускается также размеры массива передавать не в кортеже, а отдельными значениями, например, в случаее двумерноного массива: fill(value, size_1, size_2).

## Ссылки на срезы массива, функция view (макрос @view)

В языке Julia любой срез является копией некоторой части заданного массива, т.е. другим массивом.

Однако часто требуется получить ссылку на часть заданного массива, причем так, чтобы работать с этой ссылкой формально можно было бы так же как с отдельным массивом. Для этой цели в языке Julia пердусмотрена встроенная функция view. Например,

```julia
A=[10 20 30
   40 50 60
   70 80 90]
   
B = view(A,:,2)

# B - это ссылка на срез A[:,2]:

B[1]=0
println(A)
  [10  0 30
   40 50 60
   70 80 90]
```

Вместо вызовов функции view более удобно пользоваться соответствующим макросом @view, например:

```julia
B = @view A[:,2]
```

результат будет в точности тот же.

## Пример исспользования ссылок на срезы

**Задача.** Требуется написать функцию, осуществляющую сортировку каждого столбца матрицы по отдельности методом "пузырька".

**Указание.** Для этой функции использовать тоже самое имя, что и для функции осуществляющей сортировку вектора методом "пузырька", воспользовавшись механизмом множественной диспетчеризации языка Julia.

**Решение.**

```julia
function bubblesort!(A::AbstractMatrix)
    for j in size(A,2)
        bubblesort!(@view A[:,j]) # - осуществляется сортировка j-го столбца с помощью ранее написанной функции
    end
    return A
end
```

Следующая функция реализуют сортировку копии исходного массива

```julia
bubblesort(A::AbstractMatrix{T}) where T <: Union{Real,Char,String} = bubblesort!(copy(A))
```

Каждая из следующих двух функций возвращают матрицу, столбцы которой содержат перестрановку индексов элементов соответствующих столбцов, произошедших в результате их сортировок (методом "пузырька").

```julia
function bubblesortperm!(A::A::AbstractMatrix{T}) where T <: Union{Real,Char,String}
    indexes = Matrix{Int}(undef,size(A)) 
    for j in size(A,2)
        indexes[:,j] = bubblesortperm!(@view A[:,j]) 
    end
    return indexes
end

bubblesortperm(A::AbstractMatrix{T}) where T <: Union{Real,Char,String} = bubblesortperm!(deepcopy(A))
```

**Замечание 1.** Если вместо сортировки столбцов матрицы требуется выполнить сортировку её строк, то это можно будет реализовать с помощью уже имеющихся функций, использую операцию транспонирования.

**Замечание 2.** Сортирвать строки матрицы непосредственно было бы нежелательно по следующим двум причинам.

Во-первых, поскольку срез матрицы, являющийся её строкой - это в формальном отношении двумерный, а не одномерный массив, то для сортировки строк матрицы механизм множественной диспетчеризации работать уже не будет (вместо этого возникнет рекурсия).

Второй, и более весомой, причиной является то, что попытка создать ссылку на строку матрицы (@view A[i, :]) привела бы к тому, что компилятор Julia сгенерировал бы не слишком эффективный код. Это произошло бы по той причине, что в языке Julia, следуя традиции языка Fortran,  матрицы размещаются в памяти по столбцам, а не по строкам (как это имеет место в таких языках, как C/С++, Python). Последнее означает, что ссылка на строку не была бы ссылкой на непрерывную область памяти, что и привело бы к указанной проблеме.

## Cортировка вектора по значению заданной функции

Иногда требуется сортировать вектор не по значениям его элементов, а по значениям некоторой функции от его элементов. Например, может понадобиться отсортировать вектор по значениям абсолютных величин его элементов. Для этого встроенные функции sort!, sort, sortperm!, sortperm имеют именованный параметр (функционального типа), по умолчанию имеющий значение identity (identity - это встроенная функци одного аргумента, возвращающая просто значение своего аргумента).

Таким образом, если не изменить значение именнованного параметра на другое, сотрироваться массив будет, как мы ранее и предполагали, просто по значениям элементов. Но если, например, потребуется отсортировать некоторый массив A по значениям абсолютных величин его элементов, то с помощью встроенной функции sort! это следовало бы сделать так:

```julia
sort!(A, by=abs)
```

**Задача.** Добавить во все ранее написанные функции сортировки такой именованный параметр by.

## Сортировка столбцов матрицы по ключу

Ключем будем называть любую вещественно-значную функцию, определенную на строках матрицы. Например, в качестве ключа можно было бы использовать сумму элементов столбца, или сумму квадратов его элементов, или максимальное (минимальное) значение его элементов, число нулевых элементов в столбце и т.п.

Ключ удобно задавать в виде вектора значений ключевых значений столбцов. Каждый элемент такого вектора должен быть равен ключеввому значению соответствующего столбца. Например, если требуется отсортировать столбцы матрицы по значениям их сумм, то должен быть задан вектор, содержащий эти суммы. Тогда такой вектор можно отсортировать, например, с помощью встроенной функции sortperm!, а затем уже перставить столбцы заданной матрицы в соответствии с полученным векторм перестановок индексов столбцов.

**Задача.** Написать функцию, осуществляющую сортировку столбцов матрицы по произвольно заданному значению ключа.

**Решение.**

```julia
sortkey!(A::AbstractMarix, key_values) = A[:, sortperm!(key_values)]
```

Например, теперь переставить столбцы некоторой матрицы A в порядке неубывания их сумм можно так

```julia
sortkey!(A, sum(A, dim=1))
```

где значение именованного параметра dim = 1 встроенной функции sum указывает на то, что функция sum сформирует вектор, составленный из сумм столбцов матрицы A (т.е. - что суммурование должно осуществляется вдоль первой размерности матрицы).

## Сортировка методом подсчета (сортировка за линейное время)

В случае, если значения элементов сортируемого массива (A), являются элементами некоторого заранее известного относительно небольшого множества (values), то отсортировать такой массив можно за $O(n)$ операций следующим образом. Будем считать, что множество значений values представлено одноименным отсортированным массивом или диапазоном (тут вжно только, чтобы выполнялось условие values[i] < values[i+1]).

Сначала надо перебрать все элементы в массиве A и подсчитать, сколько раз встретилось каждое значение из данного набора значений values, а затем остается только в мвссив a поместить значение values[1] подсчитанное число раз, затем - values[2], и т.д., и, наконец, - values[end].

```julia
function calcsort!(a, values)
    num_val = zeros(Int, size(values))
    for v in a
        num_val[indexvalue(v,values)] += 1
    end
    k=1
    for i in eachindex(values)
        for j in 1:num_val[i]
            a[k] = values[i]
            k+=1
        end
    end
    return a
end
```

Здесь вспомогательная функция indexvalue(v, values) возвращает индекс значения v в наборе значений values. Реализация этой функции зависит от способа представления набора значений values.

В случае, если values - это диапазон целых чисел, то возможна следующая реализация.

```julia
indexvalue(v, values::UnionRange) = v - values[1] + 1
```

В случае, если values - это отсортированный вектор значений, то возможна также следующая реализация.

```julia
indexvalue(v, values::Vector) = findfirst(v, values)
```

**Замечание.** Если массив А является целочисленным, то множество всехвозможных значений элементов этого массива содержится в диапазоне minimum(A):maximum(A). Поэтому функция, реализующая сортировку целочисленного массива методом подсчета (что возможно, если только этот диапазон не является чрезмерно большим) может не иметь второго парметра. А именно

```julia
function calcsort!(A::Vector{<:Integer})
    min_val, max_val = extrema(A)
    num_val = zeros(Int, max_val-min_val+1) # если не указать здесь тип Int, то в дальнейшем это привело бы к ошибке (индексы должны быть целыми)
    for val in A
        num_val[val-min_val+1] += 1
    end  
    k = 0
    for (i, num) in enumerate(num_val)
        A[k+1:k+num] = min_val+i-1
        k += num
    end
end
```

Здесь была использована встроенная функция extrema, возвращающая два экстремальных значения массива.