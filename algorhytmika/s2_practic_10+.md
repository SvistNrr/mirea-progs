# Практика 10

1. Написать функцию, приводящую матрицу к ступенчатому виду с помощью элементарных преобразований строк

**Указание.** Реализовать выбор ведущих элементов столбцов (наибольших по абсолюной величине). Сравнение значения ведущего элемента с нулем осуществить с точностью до некоторой заданной величины epsilon (1e-7)

**Решение.**

```julia
function transform_to_steps!(A::AbstractMatrix; epsilon = 1e-7, degenerate_exeption = true)
   # @inbounds - заметного ускорения здесь это не даёт!!!
   for k ∈ 1:size(A, 1)
        absval, Δk = findmax(abs, @view(A[k:end,k]))
        (degenerate_exeption && absval <= epsilon) && throw("Вырожденая матрица")
        Δk > 1 && swap!(@view(A[k,k:end]), @view(A[k+Δk-1,k:end])) 
        for i ∈ k+1:size(A,1)
            t = A[i,k]/A[k,k]          
            @. @views A[i,k:end] = A[i,k:end] - t * A[k,k:end] 
            # макрос @. заменяет все "сквозные точки"
            # макрос @views заменяет многократное применение макроса @view
        end
    end
end
#=
Вместо:

    Δk > 1 && swap!(@view(A[k,k:end]), @view(A[k+Δk-1,k:end])) 
можно было бы так:
    if Δk > 1
        A[k,k:end], A[k+Δk-1,k:end] = A[k+Δk-1,k:end], A[k,k:end]
    end 
=#

function swap!(A,B)
    for i in eachindex(A)
        A[i], B[i] = B[i], A[i]
    end
end
```

2. Реализовать приведение матрицы к ступенчатому виду с помощью элементарных переобразований столбцов (соответствующую функцию можно назвать transform_to_steps_2!).

Провести временные замеры для этих двух алгоритмов на больших случайных матрицах.

Убедиться, что существенных отличий в скорости не будет.
**Вопрос:** как это объяснить, ведь матрицы в Julia размещаются в памяти по столбцам, и, казалось бы, исходя из этого, второй алгоритм должен бы иметь преимущество.

3. Доработать (изменить) функцию transform_to_steps! так, что бы она возвращала вектор, содержащий индексы тех столбцов приведенной к ступенчатому виду матрицы, в которых НЕ содержатся её "угловые" элементы (в порядке возрастания индексов этих столбцов); так, если матрица не вырожденная, то будет возвращен пустой вектор.

4. Используя доработанный вариант функции transform_to_steps!, написать функцию, возвращающую ранг матрицы, а также - функцию, возвращающую определитель матрицы.

**Указание.** Функции, возвращающие ранг или определитель матрицы, не должны "портить" (т.е. изменять) передаваемую им матрицу.

**Замечание.** В пакете LinearAlgebra имеется соответствующие функции rank и det (поэтому свои функцию лучше назвать иначе, например, rank_, det_).

5. Написать функцию, решающую СЛАУ вида Ax=b (матрица A пердполагается не вырожденной). Эта функция не должна "портить" передаваемые ей (по ссылке) внешние массивы A и b.

6. Написать функцию, получающую на вход матрицу A и вектор b, и возвращающую единственное решение СЛАУ Ax=b, в случе, если матрица A - не выроженная, или - пустой кортеж, если СЛАУ не совместна, или - двухэлементный кортеж из прямоугольной матрицы, столбцы которой содержат фундаментальную систему решений соответствующей однородной СЛАУ и из вектора с каким-либо частным решением исходной неоднородной СЛАУ, если эта система совместна, но её матрица вырожденная.

7. Используя функцию transform_to_steps!, напиать функцию, возвращающую обратную матрицу (матрица A пердполагается не вырожденной).

**Замечание.** В Julia имеется соответствующая встроенная функция inv (поэтому свою функцию лучше назвать иначе, например, inv_).