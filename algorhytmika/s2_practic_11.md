# Практика 11

При выполнении следующих заданий удобно будет использовать блокноты Jupyter (см. лекцию 6).

При этом рекомендуется программный код размещать в jl-файлах, а в ячейки блокнота вставлять содержащиеся в них определения функций с помощью include. После чего вызывать функции на исполнение можно будет уже из ячеек блокнота.

1. Написать функции, осуществляющие следующие действия.

- Поиск точки пересечения (если она существует) двух заданных отрезков на плоскости.

- Вычисление угла между двумя направлениями на плоскости (заданными соответствующими векторами).

- Проверка, лежат ли две заданные точки плоскости по одну сторону от заданной (с помощью неявной функции) границы области.

- Проверка, лежат ли две заданные точки плоскости по одну сторону от заданной прямой.

- Проверка, является ли заданный плоский многоугольник выпуклым.

- Проверка, лежит ли заданная точка плоскости внутри заданного выпуклого многоугольника (как было предложено в лекции 5).

- Проверка, лежит ли заданная точка плоскости внутри заданного многоугольника (не обязательно выпуклого, см. лекцию 6).

**Указание.** Для решения всех перечисленных выше задач, кроме последней, воспользоваться материалом лекции 5.

2. Написать функцию, реализующую алгоритм Джарвиса построения выпуклой оболочки заданных точек плоскости (см. лекцию 6).

3. Написать функцию, реализующую алгоритм Грехома построения выпуклой оболочки заданных точек плоскости (см. лекцию 6).

4. Написать функцию, возвращающую значение ориентированной площади заданного плоского многоугольника, воспользовавшись методом трапеций (см. лекцию 6).

5. Написать функцию, возвращающую значение ориентированной площади заданного плоского многоугольника, воспользовавшись методом треугольников (см. лекцию 6).

6. Пусть имеется некоторый выпуклый многоугольник (выпуклая оболочка некотрого множества точек плоскости) и дана ещё дна тока. Требуется написать функцию, строющую выпуклую оболочку множества точек, включающее также и эту новую точку.

**Замечание.** Если последняя задача решена, то тем самым фактически получен ещё один алгоритм построения выпуклой оболочки заданного множества точек. В самом деле, сначала можно взять какие-либо три точки из заданного множества, не лежащие на одной прямой, а затем останется только с помощью разработанной функции, поутем поочередного добавления всех остальных точек, построить искомую выпуклую оболочку.

Следует отметить, что такой алгоритм вычисляет индуктивную функцию, представляющую собой функцию, определенную на последовательностях точек, значениями которой являются соответсвующая выпуклая оболочка.

7. Реализовать построение выпуклой оболочки указанным выше способом.

**Указание.** При получении новой точки надо определить, является ли она внутренней или внешней точкой по отношению к уже имеющейся выпуклой оболочке. Если она оказалась внутренней, то выпуклая оболочка остается прежней. Если же точка оказалась внешней, то надо определить две "крайние" вершины прежней выпуклой оболочки, через каждую из которых можно провести из новой точки луч, таким образом, чтобы он не проходил через её внутренние точки. После этого остается только заменить соответствующую часть вершин ранее построенной выпуклой оболочки на одну новую вершину, и таким образом получить выпуклую оболочку, включающую её.

Алгоритм реализовать с использованием встроенной функции высшего порядка reduce.

8. Пусть в дополнение к условию задачи 6 известна площадь имеющейся выпуклой оболочки. Требуется аналогично задаче 7 реализовать вычисление индуктивной функции, возвращающей как саму выпуклую оболочку, так и ее площадь.

**Указание.** На каждом шаге алгоритма для вычисления приращения площади выпуклой оболочки использовать метод треугольников.

--------------------- Дополнительные задания
9. Написать функцию, проверяющую, явлется ли заданная последовательность точек (пердставленная типом Vector{Vector2D}), вершинами некоторого многоугольника (у многоугольника никакие две его стороны не пересекаются внутренним образом).
    
**Указание.** Воспользоваться ранее написанной функцией intersect, возвращающей координаты точки пересечения двух отрезков, если такая точка существует. При отсутствии точки пересечения функция возвращае или noting, или при её выполнении возникнет исключительная ситуации, если отрезки лежат на параллельных прямых. Эту возможную исключительную ситуацию следует перехватывать с помощью конструкции try-cath-end). Но прежде чем вызывать функцию intersect, следует проверить, являются ли в заданной последовательности точек все точки уникальными (в противном случае они заведомо не могут быть вершинами никакого многоугольника).

10. Написать функцию, вычисляющую выпуклую оболочку объединения некоторых двух множест точек плоскости, если заданы выпуклые оболочки каждого из них (сами множества считаются не заданными).

11. Написать функцию, вычисляющую выпуклую оболочку пересечения каких-либо двух множест точек плоскости, если заданы выпуклые оболочки каждого из них (сами множества считаются не заданными).

**Указание.** Сначала в каждую из двух заданных выпуклых оболочек добавить вершины, лежащие в точках пересечения их сторон, если, конечно, точки пересечения существуют и не совпадают с какой-либо уже имеющейся вершиной. Для поиска точек пересечения воспользоваться разработанной ранее функцией. Затем из каждой выпуклой оболочки удалить лишние вершины, а оставшиеся вершины в нужном порядке поместить в список вершин искомого пересечения.

**Замечание.** Имеется встроенная функция allunique, проверяющая уникальность элементов заданной последовательности. Также имеется функция unique, удаляющяю повторяющиеся элементы из заданного вектора.