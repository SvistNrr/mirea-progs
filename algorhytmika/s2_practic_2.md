# Практическое занятие 2

1. Реализовать все алгоритмы, обсуждавшиеся в лекции 1.
?????
2. Реализовать встроенную функцию reverse!, "переворачивающую" массив.
3. Написать функцию, осуществляющую сдвиг элементов **числового** массива на одну позицию вправо, заменяя освободившуюся позицию **нулем**.
4. Написать две функции, осуществляющую циклический сдвиг элементов массива на одну позицию вправо и влево, соответственно (функции удобно будет назвать circhift_right!(a), circhift_left!(a)).

**Замечание.** В случае циклического сдвига уже не обязательно предполагать массив числовым (поскольку не потребуется в него записывать число нуль).

**Решение.**

```julia
function circhift_right!(a)
    buf = a[end]
    for i in lastindex(a):-1:firstindex(a)-1
        a[i] = a[i-1]
    end
    a[begin] = buf
end

function circhift_left!(a)
    buf = a[begin]
    for i in firstindex(a):lastindex(a)-1
        a[i] = a[i+1]
    end
    a[begin] = buf
end
```

5. Написать функцию, осуществляющую циклический сдвиг элементов массива на `K` позиций, обеспечивающую сложность $O(N)$: если `K > 0`, то - вправо, если `K < 0`, то - влево. При этом вспомогательный массив не использовать.

**Замечание 1.** Имеются встроенные функции `circshift!`, `circshift`, решающие данную задачу.

**Замечание 2.** Если искомый алгоритм свести к повторному вызову `K` раз функции, осуществляющей сдвиг всего массива на одну позицию, то оценка сложности такого алгоритма была бы $O(N^2)$ (если предполагать, что диапазон возможных значений `|K|` есть `1:N-1`).

**Решение 1.**

```julia
????
```

**Решение 2.**  Для осуществления циклического сдвига элементов массива на `k` позиций также можно было бы воспользоваться следующей идеей.

Пусть, например, `k > 0`, тогда требуемый результат будет получен, если в массиве сначала перевернуть задом на перед каждую из двух его частей: с `1`-го по `k`-ый элемент, и с `k+1`-го по последний элемент, а затем перевернуть уже весь массив целиком еще раз.

```julia
function _circshift!(a, k)
    if k > 0
        reverse!(@view(a[1:k]))
        reverse!(@view(a[k+1:end]))
        reverse!(a) 
    elseif k < 0
        reverse!(a)
        reverse!(@view(a[1:-k]))
        reverse!(@view(a[-k+1:end]))
    end
    return a
end
```

1. Реализовать встроенные функции `isperm`, `permute!`, `invpermute!` (сложности $O(N)$ и не используюя вспомогательного массива)

Для реализации функции `isperm` (проверяющую, представляет ли заданный вектор целых чисел некотрую перестановку чисел `1,2,...,N`, или нет) достаточно проверить, во-первых, что, все его элементы принадлежат диапазону `1:N` (`N` - длина заданного вектора), и, во-вторых, что все содержащиеся в нем числа различны.

**Указание.** Постараться самостоятельно реализовать функцию `isperm`, а затем сравнить свой код, с кодом разработчиков Julia, который имеет следующий вид.

```julia
function _isperm(p)
    n = length(p)
    used = falses(n) # возвращает нулевой BitVector длины n
    for i in p
        (i in 1:n) && (used[i] ⊻= true) || return false # значек ⊻ - обозначает "исключающее или" 
    end
    true
end
```
  
Функция invpermute!, выполняющая обратную перестановку, реализуется проще чем, функция permute!, выполняющая заданную перестановку индексов p, которая соответствовала бы срезу массива A[p].

```julia
function _invpermute!(A, p)
    for i in p
        if i > 0
            A[i], A[p[i]] = A[p[i]], A[i]
            p[i] = -p[i]
        end
    end
    for i in eachindex(p)
        p[i] = -p[i]
    end
    return A   
end
```

**Указание.** При реализации функции permute! воспользоваться тем фактом, что любая перестановка индексов представляет собой совокупность циклических перестановок некоторого числа непересекающихся наборов индексов.

```julia
function _permute!(A, p) 
    for i in eachindex(p)
        if p[i] < 0
            continue
        end 
        # i - начало очередной циклической перестановки индексов массива A            
        buff = A[i]
        j_prew, j = i, p[i] # - индекс элемента исходного массива, который требуется переместить на i-ю позицию                  
        p[i] = -p[i]
        while j != i # - пока циклическая перестановка индексов не "замкнулась"               
            A[j_prew] = A[j]
            j_prew, j = j, p[j]            
            p[j_prew] = -p[j_prew]
        end        
        A[j_prew] = buff 
        # перемещения элементов массива A по очередному циклу (по очередной циклической перестановке индексов) полностью завершены
    end
    for i in eachindex(p)
        p[i] = -p[i]
    end        
    return A
end
```

**Замечание.** Возможна также следующая реализация функции permute!

```julia
function __permute!(A, p) 
    inv_p = similar(p)
    inv_p[p] .= 1:length(p) 
    _invpermute!(A, inv_p)
end
```

Однако эта реализация потребовала создания вспомогательного массива, для размещения обратной перестановки индексов inv_p.