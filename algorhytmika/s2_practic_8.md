# Практика 8

# Вычисление частичной суммы степенного ряда, с использованием рекуррентной формулы

**Задача 1.** Известно, что

$$ e= \lim_{n \to \infty} \Big(\frac{1}{0!} + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + ...+\frac{1}{n!} \Big) = \frac{1}{0!} + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + ...$$

Следующий программный код вычисляет n-ю частичную сумму этого ряда (сумму его первых n слагаемых):

```julia
# n - заданное число
sum_n = 0
for k in 0:n
    sum_n += 1/factorial(k)
end
```

Требуется дать асимптотическую оценку алгоритмической сложности этого алгоритма (в зависимости от числа n).

Оценка алгоритмической сложности функции factorial(k) есть $O(k)$. Поэтому общая оценка алгоритмической сложности всего алгоритма получается $O(n^2)$, поскольку $1+2+...+n=n(n+1)/2$.

Однако ту же самую частичную сумму можно вычислять так, чтобы оценка сложности была $O(n)$. В самом деле, вычисляя factorial(k), мы никак не использовали то, что на предыдущем шаге было вычислено factorial(k-1), что приводит к повторным вычислениям.

Чтобы избавиться от повторных вычислений, тут надо воспользоваться рекуррентным соотношением:

$$ f_k=f_{k-1}\cdot k, $$

где $f_k=k!$, при начальном значении $f_0=1$.

Или, что еще лучще,
$$ a_k=a_{k-1}/k, $$
где $a_k=\frac{1}{k!}$, при начальном значении $a_0=1$, поскольку на каждой итерации это будет экономить ещё одну арифметическую операцию (деления).

Таким образом, имеем эффективное решение

```julia
# n - заданное число
s = 0.0
a = 1.0
for k in 1:n+1 
# границы значений индекса k по отношению к прежнему варианту теперь смещены на 1 вправо
    s += a
    a /= k
end
```

Это процедура с оценкой сложности $O(n)$.

**Вопрос.** При n > 20, выполнение следующего кода приведет к ошибке (OverflowError - ошибка переполнения переменной).

```julia
sum_n = 0.0
for k in 0:n
    sum_n += 1/factorial(k)
end
```

Почему при том же условии (n > 20) выполнение следующего кода к этой ошибке уже не приводит?

```julia
# n - заданное число
s = 0.0
a = 1.0
for k in 1:n+1 
# границы значений индекса k по отношению к прежнему варианту теперь смещены на 1 вправо
    s += a
    a /= k
end
```

**Задача 2.** Выполнить следуюшие пункты.

- Оформить предыдущий алгоритм в виде функции с заголовком: eyler(n), где параметр n \- это число слагаемых частичной суммы.
- Экспериментально убедиться, что начиная с некоторого достаточного большого значения n результат вычислений перестаёт изменяться.  Требуется дать этому факту объяснение, исходя из свойств арифметики с плавающей точкой.

- Объяснить, что получится в результате выполнения следующей функции, и почему при её выполнении не будет происходить зацикливания.

```julia
function eyler()
    s = 0
    a = 1
    k = 0
    while s + a != s
        k += 1
        s += a
        a /= k
    end
    return s
end
```

**Замечание 1.** Объяснение состоит в том, что при вычислении `s+a` должны будут складываться соответствующие 53-х битные мантиссы (здесь речь идет о формате типа Float64). Но сначала порядок меньшего слагаемого должен быть приведен к порядку большего слагаемого путем "сдвига" его мантиссы вправо с заменой "освобождающихся" битов нулями. Таким образом, если сдвиг составит 53 бита или больше, то мантисса меньшего числа окажется полностью замененной нулями.

**Замечание 2.** Путем сохранения значения sum_n + a_n в дополнительной переменной уменьшить число оперераций сложения в цикле на 1.
  
## Суммирование сходящегося ряда с заданной точностью

Пусть требуется просуммировать сходящийся бесконечный ряд

$$ s= \lim_{n \to \infty} \Big(a_1+a_2+...+a_n \Big) =a_1+a_2+...+a_k+... $$

с наперед заданной точностью $\varepsilon > 0$, т.е. подобрать такое число $n$, чтобы

$$ |s-s_n|\le \varepsilon $$

где

$$ s_n=a_1+...+a_n $$

\- это $n$-я частичная сумма ряда, а

$$ s=\lim_{n \to \infty}s_n $$

\- это сумма ряда.

Здесь нам понадобится следующий факт из математического анализа (с которым в скором времени вы познакомитесь в курсе математического анализа).

Числовой ряд называется знакопеременным, если

$$ \forall k \ a_k \cdot a_{k+1}<0 $$

**Теорема** (признак Лейбцица сходимости знакопеременного ряда).

Пусть имеется знакопеременный числовой ряд

$$ a_1+...+a_k+... $$

тогда данный ряд сходится, если выполнены следующие два условия

- $a_k \to 0, \ k \to \infty$

- стремление к нулю $k$-го члена ряда является монотонным, т.е. $|a_k|<|a_{k+1}|$ (по крайней мере начиная с некотрого $k_0$, т.е. для $k\ge k_0$);

при этом (что для нас особенно важно)

$$ |s-s_n|\le |a_{n+1}| $$

т.е. величина погрешности, с которой $n$-я частичная сумма апроксимирует искомую сумму ряда, не превосходит величины первого "отбрасываемого" члена ряда (знакочередующегося).

Таким образом, чтобы просуммировать знакочередующийся ряд с заданной точностью, достаточно прекратить суммирование (прервать соответствующий цикл) при выполнении условия $|a_k|<=\varepsilon$.

**Замечание.** Рассматриваемая величина $\varepsilon$ определяет оценку **абсолютную погрешность** $\Delta s = |s-s_n|$ искомой величины $s$. Наряду с абсолютной погрешность в вычислениях важное значение играет понятие **относительной погрешности** $\delta s = \Delta s / |s|$ (предполагается, что $s \ne 0$).

**Задача 3.** Известно, что функция $\sin(x)$ в окрестности нуля представляется своим рядом Тейлора

$$ \sin(x)=\frac{x}{1!}-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+... $$

Этот ряд сходится при всех $x$ и является знакочередующимся.

Требуется написать функцию, вычисляющую по этой формуле значение $\sin(x)$ для заданного $x$ с заданной максимально допустимой погрешностью $\varepsilon>0$.

**Замечание.** Если фиксировать значение перемнной $x$, то расматриваемый степенной ряд есть просто числовой ряд, и, следовательно, к нему можно применить теорему Лейбница о сходимости знакочередующегося числового ряда.

**Указание.** Для построения эффективного алгоритма, вычисляющего частичные суммы рассматриваемого ряда, сначала получить рекуррентную формулу для вычисления k-члена этого ряда.

Имеем

$$ a_k=(-1)^{k-1}\frac{x^{2k-1}}{(2k-1)!} $$

где $k=1,2,3,...$.

Тогда

$$ \frac{a_{k+1}}{a_k}=\frac{(-1)^{k}\frac{x^{2k+1}}{(2k+1)!}}{(-1)^{k-1}\frac{x^{2k-1}}{(2k-1)!}}=-\frac{x^2}{2k(2k+1)} $$

Откуда уже получаем искомую рекуррентную формулу:

$$ a_{k+1}=-a_k\cdot \frac{x^2}{2k(2k+1)} $$

Основываясь на найденной формуле, можно уже написать требуемую функцию.

```julia
function Base.sin(x,ε)
    xx=x^2
    a=x
    k=1
    s=typeof(x)(0) # - преобразование к 0 нужного типа, что обеспечит стабильность типа переменной s
    while abs(a)>ε
        s+=a
        a=-a*xx/2k/(2k+1)
        k+=1
    end
    #УТВ: |sin(x)-s|<= ε
    return s
end
```

Код этой функции можно ещё немного оптимизировать, т.е. уменьшить число арифметических операций, выполняемых на каждой итерации, если заметить, что последовательность значений $2k$ ($k=1,2,3,...$) представляет собой последовательность четных чисел, которую можно получать на основе рекуррентного соотношения:

$$ m_{k+1}=m_k+2 $$

где $m_k=2k$, при начальном условии $m_1=2$. Т.е.

```julia
function Base.sin(x,ε)
    xx=x^2
    a=x
    m=2
    s=typeof(x)(0) 
    while abs(a)>ε
        s+=a
        a=-a*xx/m/(m+1)
        m+=2
    end
    #УТВ: |sin(x)-s|<= ε
    return s
end
```

**Вопрос**: что получится, если в этом цикле условие $|a|>ε$ заменить условием $s+a \ \ \ != s$?

**Замечание.** Следующие варианты ответа являются не верными:

- "произойдет зацикливание, поскольку равенство невозможно, в виду того, что всегда `a>0`;

- величина `a` от итерации к итерации постоянно уменьшается, поэтому цикл завершится, как только её значение достигнет значение машинного нуля (для Float64 равного приблизительно `1e-324`).

**Правильный ответ**: цикл завершится, как только разность двоитчных порядков величин `s` и `a` достигнет `53` (что примерно соответствует шестнадцати десятичный порядков).

С учетом сказанного, функция, вычисляющая значение sin(x) можем быть запрограммирована следующим образом.

```julia
function sin_(x) 
    xx=x^2
    a=x
    m=2
    s=typeof(x)(0) 
    while s+a != s
        s+=a
        a=-a*xx/m/(m+1)
        m+=2
    end
    #УТВ: |sin(x)-s| <= 1е-16
    return s
end
```

**Задача 4.** Воспользовавшись известным разложением

$$ \exp(x) = 1 + x + \frac{x^2}{2!}+...+\frac{x^k}{k!}+...$$

написать функцию `exp_(x)`, вычисляющую значение `exp(x)`.

**Экспериментально убедиться**, что, например, exp_(-20) даст значение, в мантиссе которого не будет ни одной верной цифры, в то время как верное значение можно будет получить, вычислив 1/exp_(20) (для контроля результатов вычислений следует использовать встроенную функцию exp(x), котрорая выдает адекватный результат для любого своего аргумента).

**Замечаниею** Объяснение указанного факта состоит в следующем.
Если аргумент функции `exp_(-20)` меньше нуля, то при её вычислении суммируется **знакопеременный** ряд, причем значение искомой суммы ряда - есть величина близкая к нулю (порядка 1e-9).

Таким образом, во-первых, при этих вычислениях неизбежно придется из одного маленького числа вычитать другое, тоже маленькое, примерно того же порядка. И это будет приводить к потере точности, связанной с тем, что при вычитанни одной мантиссы из другой в очень многих старщих разрядах будут получаться нули, и это будет означать укорочение мантиссы результата вычитания (т.е. потерю точности).

При этом относительная погрешность результата будет возрастать ещё сильнее (см. определение относительной погрешности, приведенное выше).

**Задача 5.** Проанализировать следующую ситуацию, предварительно проведя соответствующие численные эксперименты.

Известно, что

$$ \lim_{n \to \infty} \Big(1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+... + \frac{1}{n} \Big)=\infty$$

т.е. что числовой ряд

$$ 1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+... $$

расходится (этот расходящийся ряд называется **гармоническим**).

Можно написать функцию, "вычисляющую сумму" этого (расходящегося!) ряда, воспользовавшись прежним приёмом численного суммирования.

```julia
function harmonic_sum()
    s=0.0
    k=1
    a=1.0
    while s+a != s
        a=1/k
        s+=a 
        k+=1
    end
    return s
end
```

Теоретически данный цикл будет завершен, как только разность двоичных порядков величин `s` и `a` достигнет `53`. Когда-нибудь это должно будет произойти, поскольку величина `s` от итерации к итерации монотонно возрастает, а величина `a` монотонно убывает. Однако на практике дождаться этого события врядли получится, поскольку и то и другое будет происходить довольно медленно.

**Задача 6**. Написать функцию, вычисляющую $n$-ую частичную сумму ряда Тейлора функции

$$\cos(x)=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+...$$

для заданного значения аргумента $x$. Вычислительная сложность алгоритма должна иметь оценку $O(n)$.

**Задача 7**. Написать функцию, вычисляющую значение суммы ряда Тейлора функции $\cos(x)$ в заданной точке с машинной точностью.

**Указание**. Постараться минимизировать число арифметических операций.

Протестировать функцию, путем сравнения получаемых результатов с результатами, выдаваемыми встроенной функцией $\cos(x)$.

**Задача 8**. Построить семейство графиков $n$-ых частичных сумм ряда Тейлора функции $\cos(x)$ на одном её периоде, для $n=2,4,8,16$.

**Указание.** Допустим имеется функция `part_sum(n,x)`, возвращающая значение n-ой частичной суммы в точке х. Чтобы построить её график на интервале от 0 до 10, например, для n=4, средствами Julia достаточно будет написать следующий код.

```julia
using Plots

x = 0:0.1:10
plot(x, part_sum.(4,x))
```

А чтобы постоить семейство графиков, например, для n=2,4,6,8, достатчно заменить последнюю строчку приведенного кода на следующий код.

```julia
p = plot() # получена ссылка на пустой график
for n in 2:2:8
    plot!(p, x, part_sum(n,x)) # в текущий график добавлена новая кривая
end
display(p) # график, содержащий семейство кривых, отображен
```

**Задача 9**. Получить рекуррентные соотношения, требуемые для суммирования без повторных вычислений следующих степенных рядов

$$
1)\ \ln(x)=\sum_{k=0}^\infty(-1)^k\frac{(x-1)^{k+1}}{k+1}, \ \ \ 0 < x < 1
$$
(**указание:** положить $a_k=(-1)^k(x-1)^{k+1}/(k+1)=b_k/(k+1)$, где $b_k=-(1-x)^{k+1}$ и для вычисления последовательности $b_k$ получить  рекуррентную формулу);
$$
2)\ \frac{1}{\sqrt{1+x}}=1+\sum_{k=1}^{\infty}(-1)^k\frac{1\cdot3\cdot5\cdot...\cdot (2k-1)}{2\cdot4\cdot6...\cdot(2k)}x^k
$$
(**указание:** для вычисления последовательности $a_k=(-1)^k\frac{1\cdot3\cdot5\cdot...\cdot (2k-1)}{2\cdot4\cdot6...\cdot(2k)}x^k$ получить рекуррентную формулу);
$$
3)\ x\sin x - \exp(-x^2)+1=\sum_{k=1}^{\infty}(-1)^{k+1}\Big(\frac{1}{k!}+\frac{1}{(2k-1)!}\Big)x^{2k}
$$
(**указание:** положить $(-1)^{k+1}\Big(\frac{1}{k!}+\frac{1}{(2k-1)!}\Big)x^{2k}=u_k(v_k+w_k)$, где $u_k=(-1)^{k+1}x^{2k},\ v_k=1/k!, w_k=1/(2k-1)!$ и последователности $u_k,v_k,w_k$ вычислять по соответствующим рекуррентным формулам).

Для контроля правильности просуммировать эти ряды с машинной точностью в точке $x=0.5$, и полученные результаты сравнить со значениями соответствующих функций (указанных в левых частях равенств).

**Задача 10**. Следующий степенной ряд определяет семейство так называемых функций Бесселя 1-го рода порядка $m$ ($m=0,1,2,...$)
$$
J_m(x)=\Big(\frac{x}{2}\Big)^m\sum_{k=0}^{\infty}\frac{(-1)^k}{k!(k+m)!}\Big(\frac{x}{2}\Big)^{2k}
$$
Написать функцию `besselj(m,x)`, вычисляющую функцию Бесселя 1-го рода порядка $m$ в точке $x \in \mathbb{R}$ с машинной точностью, и построить семейство графиков для $m=0,1,2,3,4,5$
(вид требуемых графиков см., например, [здесь](https://ru.wikipedia.org/wiki/Функции_Бесселя)).

**Замечание.**  Определение функции besselj(m,x) имеется также  в пакете [SpecialFunctions.jl](https://juliamath.github.io/SpecialFunctions.jl/stable/), который требует предварительной установки.
