# Лекция 5

## Численное решение СЛАУ методом Жордана-Гаусса

Пусть имеется СЛАУ, которую запишем в матричном виде:
$$
Ax=b
$$
где $A$ - матрица размера $n\times n$, $b$ - вектор-столбец длины $n$, $x$ - неизвестный вектор-столбец. Будем считать при этом, что матрица системы не вырождена.

Как известно из линейной алгебры, метод Жордана-Гаусса состоит в том, что составляется так называемая расширенная матрица системы `[A b], затем эта матрица приводится к ступенчатому виду с помощью элементарных преобразований строк матрицы (это часть процедуры принято называть "прямым ходом" метода Жордана-Гаусса), после чего найти решение системы уже просто, с помощью так назыаемого "обратного хода".

Однако численное решение СЛАУ на компьтере сопряжено с погрешностями, присущими арифметике с плавающей точкой. В ряде случаев, особенно при решении очень больших систем, эти погрешности могут достигать кактастрофических величин.

Рассмотрим причины этого более подробно. Сначала вспомним, что собой представляют элементарные преобразования строк расширенной матрицы, с помощью которых матрица приводится к ступенчатому виду.

Если матрица СЛАУ не вырожденная, то при приведении расширенной матрицы к ступенчатому виду на главной диагонали должны получаться ненулевые элементы, а все элементы ниже главной диагонали должны обнуляться.

Это достигается с помощью некоторой последовательности из следующих двух элементарных преобразований

- перестановка каких-либо двух строк расширенной матрицы
- замена $k$-ой строки расширенной матрицы суммой этой строки с какой-либо $i$-ой строкой ($i\ne k$), умноженной на некоторый коэффициет (будем обозначать такой коэффициент буквой $t$).

Цель первого преобразования состоит в том, чтобы в позиции $(i,i)$ получить ненулевой элемет (сейчас мы поймем, что, на самом деле, надо, чтобы он был не просто ненулевым, а - как можно большим по модулю).

Цель второго преобразования состоит в том, что бы применяя его последовательно для $k=i+1:n$, обнулить элементы матрицы под $(i,i)$-ой поцицией.

Для этого (уже после того как на $i$-ю позицию была перемещена нужная строка) указанный выше коэффициен $t$ для каждого $k=i+1:n$ должен вычисляться по формуле
$$
t=-\frac{a[k,i]}{a[i,i]}
$$

тогда, с учетом того, что в каждой $(i,j)$ позиции марицы в процессе вычислений накоплена некоторя ошибка, которую обозначим $\Delta_{ij}$, в позиции $(k,m)$, $m \in i:n$ имеем
$$
a[k,m]+\Delta_{k,m} + t\cdot(a[i,m]+\Delta_{i,m})
$$

и таким образом суммарная ошибка в этой позиции получается равной
$$
\Delta_{k,m} + t\cdot\Delta_{i,m}
$$

Таким образом, если величина $|t| >> 1$, то возможно быстрое нарастание погрешностей, и они могут достичь катастрофически больших величин.

Чтобы этого избежать, величина $t$ по абсолютной величине не должна превышать $1$. Для этого надо так перставлять строки в матрице, чтобы в очередной $(i,i)$-ой позиции оказывался элемент, не просто не равный $0$, а максимальный по абсолютной величине.

Вот численный пример.
![Рис. 2](lecture_2_4_fig-2.png)
Окончательный результат прямого хода метода Жордана-Гаусса
![Рис. 3](lecture_2_4_fig-3.png)

**Замечание.** На самом деле только одного предплодожения о невырожденности матицы системы не достаточно для того, чтобы получить решение методом гаусса с приемлемой точностью. Дело в том, что бывают так называемые плохообусловленные матрицы, которые могут быть и не вырожденными, но, тем не менее, погрешносити решения соответствующих СЛАУ методом Гаусса могут достигать катастрофически больших значений. Но более подробное обсуждение самого понятия и методов решения плохообусловленных СЛАУ выходят за пределы нашего курса.

## Некоторые алгоритмы вычислительной геометрии

- Выбор типа данных для представления точек (плоскости).
- Задача поиска точки пересечения (если она есть) двух заданных отрезков на плоскости.
- Задача вычисления угола между двумя плоскими прямыми.
- Задача определения, лежат ли две заданные точки плоскости по одну сторону от заданной границы области; в частности - по одну сторону от заданной прямой.
- Задача определения, лежит ли заданная точка плоскости внутри заданного выпуклого многоугольника.
- Задача определения, является ли заданный плоский многоугольник выпуклым.
- Задача построения выпуклой оболочки заданного множества точек плоскости.
- Задача вычисления ориентированной площади плоского многоугольника (любого).

## Выбор типа данных для представления точек (плоскости)

В языке Jula имеется несколько возможностей определить тип данных для представления точек плоскости.

- Точки можно представлять двухэлементными веторами `Vector{<:Real}`, например:

```julia
P=[0,0]
```

- Точку можно задать как двухэлементный кортеж `Tuple{T,T} where T<:Real`, например:
  
```julia
P=(0,0)
```

- Точку можно задать как структуру с двумя однотипными числовыми полями:

```julia
struct Vector_2D{T<:Real}
    x::T
    y::T
end
```

наример:

```julia
P=Vector_2D(0,0)
```

- Точку можно задать как именованный кортеж `NamedTuple{(:x, :y), Tuple{T,T}} where T<:Real`. Приэтом для этого типа удобно будет определить псевдоним:

```julia
Vector2D{T<:Real}=NamedTuple{(:x, :y), Tuple{T,T}}
```
  
наример:

```julia
P = (x=0,y=0)
```

или то же самое можно ещё и так:

```julia
P=Vector2D{Int}((0,0))
```

**Замечание.** Точку можно задать как значение параметрического типов, определенных пакете [StaticArrays.jl](https://juliaarrays.github.io/StaticArrays.jl/latest/), а именно типа `SVector`, или типов, производных от парметрического типа `FieldVector`.

Однако осставим этот способ за скобками, поскольку изучение этого пакета отвлекло бы нас от главной цели.

Мы остановимся на способе представления точки плоскости с помощью именованных кортежей (`NamedTuple`).

Отметим, что тип `NamedTuple` представляет собой просто некоторую "обёртку" вокруг типа `Tuple` с соответствующим (фиксированным) числом элементов.

Обращаться к элементам именованного кортежа мощжно как с помощью индексов, например, `A[1], A[2]`, или с помощью их имен, например, `A.x, A.y`.

Координаты точек полоскости - суть координаты соответствующих радиус-векторов. Поэтому не будем делать различий между точками и их радиусветорами. В соответствии с этим определим необходимые операции для представляющего их типа `Vector2D`.

```julia
using LinearAlgebra

Vector2D{T<:Real} = NamedTuple{(:x, :y), Tuple{T,T}}

Base. +(A::Vector2D{T},B::Vector2D{T}) where T = Vector2D{T}(Tuple(A).+Tuple(B))

Base. -(A::Vector2D{T}, B::Vector2D{T}) where T = Vector2D{T}(Tuple(A) .- Tuple(B))

Base. *(coeff::T, A::Vector2D{T}) where T = Vector2D{T}(coeff.*Tuple(A))

LinearAlgebra.norm(A::Vector2D) = norm(Tuple(A))
# norm(a) - длина вектора, эта функция опредедена в LinearAlgebra

LinearAlgebra.dot(A::Vector2D{T}, B::Vector2D{T}) where T = dot(Tuple(A), Tuple(B))
# dot(a,b)=|a||b|cos(a,b) - скалярное произведение, эта функция определена в LinearAlgebra

Base. cos(A::Vector2D{T}, B::Vector2D{T}) where T = dot(A,B)/norm(A)/norm(B)

xdot(A::Vector2D{T}, B::Vector2D{T}) where T = A.x*B.y-A.y*B.x
# xdot(a,b)=|a||b|sin(a,b) - косое произведение

Base. sin(A::Vector2D{T}, B::Vector2D{T}) where T = xdot(A,B)/norm(A)/norm(B)
```

## Задача поиска точки пересечения двух отрезков на плоскости

Будем считать, что отрезки задаются координатами своих концов.

Точки плоскости будем представлять именованными кортежами типа `Vector2D`, определенного нами ранее.

Уравнение прямой, проходящей через точки $A$, $B$ может быть записано в виде:

$$
\frac{x-A.x}{B.x-A.x} = \frac{y-A.y}{B.y-A.y}
$$

или в более универсальном виде:

$$
(x-A.x)(B.y-A.y)=(y-A.y)(B.x-A.x)
$$

(теперь уже не надо будет заботиться о неравенстве нулю знаменателей).

Раскрыв здесь скобки, и приведя подобные члены, перейдем к канонической записи уравнения прямой, в котором все коэффициенты выражены через координаты заданных точек $A$ и $B$:

$$
(𝐵.𝑦−𝐴.𝑦)𝑥+(𝐴.𝑥−𝐵.𝑥)𝑦=𝐴.𝑦(𝐴.𝑥−𝐵.𝑥)+𝐴.𝑥(𝐵.𝑦−𝐴.𝑦)
$$

Чтобы проверить, что отрезки пересекаются и найти их точку пересечения, потребуется

- найти точку пересечения (если она есть) прямых, содержащих данные отрезки;

- проверить принадлежность найденной точки пересечения обоим отрезкам.

Пусть $[A_1, B_1]$ и $[A_2, B_2]$ - два рассматриваемых отрезка, концы которых представлеты типом `Vector2D`.

Тогда для нахождения точки пересечения содержащих их прямых требуется решить (если решение существует) следующую систему двух линейных уравнений:

$$
(𝐵_1.𝑦−𝐴_1.𝑦)𝑥+(𝐴_1.𝑥−𝐵_1.𝑥)𝑦=𝐴_1.𝑦(𝐴_1.𝑥−𝐵_1.𝑥)+𝐴_1.𝑥(𝐵_1.𝑦−𝐴_1.𝑦)\\
(𝐵_2.𝑦−𝐴_2.𝑦)𝑥+(𝐴_2.𝑥−𝐵_2.𝑥)𝑦=𝐴_2.𝑦(𝐴_2.𝑥−𝐵_2.𝑥)+𝐴_2.𝑥(𝐵_2.𝑦−𝐴_2.𝑦)
$$

Для представления отрезка введем новый тип данных

```julia
Segments2D{T<:Real} = NamedTuple{(:A, :B), Tuple{Vector2D{T},Vector2D{T}}}
```

И для этого типа определим функцию двух аргументов, возвращающую точку пересечения заданных отрезков, или значение `noting`, если пересечения нет.

```julia
function intersect(s1::Segment2D{T},s2::Segment2D{T}) where T
    A = [s1.B[2]-s1.A[2]  s1.A[1]-s1.B[1]
         s2.B[2]-s2.A[2]  s2.A[1]-s2.B[1]]

    b = [s1.A[2]*(s1.A[1]-s1.B[1]) + s1.A[1]*(s1.B[2]-s1.A[2])
         s2.A[2]*(s2.A[1]-s2.B[1]) + s2.A[1]*(s2.B[2]-s2.A[2]]

    x,y = A\b
    # !!!! Если матрица A - вырожденная, то произойдет ошибка времени выполнения

    if isinner((;x, y), s1)==false || isinner((;x, y), s2)==false
        return nothing
    end

    return (;x, y) #Vector2D{T}((x,y))
end

isinner(P::Vector2D, s::Segment2D) = (s.A.x <= P.x <= s.B.x || s.A.x >= P.x >= s.B.x) && 
                                     (s.A.y <= P.y <= s.B.y || s.A.y >= P.y >= s.B.y)
```

**Замечание.**
При написании этой функции мы исходили из того, что уравнение вида `A*z=b` имеет единственное решение (т.е. что матрица `A` - не вырожденная). Но, как мы знаем, если матрица вырожденная, то такое уравнение может не иметь вообще решений, или иметь их бесконечно много. Таким образом, если матрица окажется вырожденной, то при выполнеии нашей функции при выполнении операции `A\b` произойдет ошибка.

Но мы сознательно пошли на это, чтобы не усложнять алгоритм. При если, например, координаты точек брать случайными, то события, кодга наша матрица окажется вырожденной будут исчезающе редкими, что не трудно понять из общих вероятностных соображений (либо проверить экспериментально).

На самом деле, тут вопрос надо ставить несколько иначе.
Рассмотрим следующий рисунок ![рисунок 1](lecture_2_5_fig-1.png), на котором изображены графики двух почти параллельных прямых.

Из рисунка ясно, что в таких случаях погрешность вычисления координат точки пересечения прямых будет тем больше, чем меньше угол между ними.

Однако величина этого угла никак не связана с величиной определителя системы, т.е. если определитель равен `0`, то и угол, конечно равен `0`, но из малости величины определителя никак не следует малость угла.

В самом деле, уравнения любой системы можно умножать на некоторое не равное `0` число, от этого графики соответсвующих им прямых не изменятся, в то время как определитель изменится, и с помощью этого множителя может быть сделан сколь угодно малым.

Свойство матрицы системы, определяющее возможность получения достаточно точного её решения, адекватно выражается не её определителем, а другой характеристикой, называемой [**числом обусловленности** матрицы](https://ru.wikipedia.org/wiki/Число_обусловленности). Но обсуждение этих вопросов сейчас пока не будет входить в наши цели (эти вопросы рассматриваются в курсе вычислительной математики).

Отметим лишь, что в пакете `LinearAlgebra` имеется функция `cond`, вычисляющая число обусловленности заданной матрицы (чем число обусловленности больше, тем хуже, совсем плохо, когда это число достигает значений $10^{12}$ и выше).

## Задача определения угла между прямыми

Вычисления угла между направляющими векторами могут основываться или на вычислении их скалярно произведения, или - на вычислении так называемого косого произведении этих векторов.

В случае использования скалярного произведения, имеется возможность определить косинус угла между векторами.

А в случае использования косого произведения векторов - синуса угла между ними.

Что лучше - зависит от конкретной задачи.

Так, если искомый угол заведомо находится в диапазоне от 0 до 180 градусов, то целесообразно вычислять косинус этого угла (т.к. значения арккосинуса лежат в этом диапазоне).

Если же искомый угол заведомо по абсолютной величине не превосходит 90 градусов, то целесообразно вычислять синус этого угла.

**Замечание.** Часто бывает, что не нужно определять само значение угла, достаточно бывает лишь иметь возможность сравнить два угда по величине. В этом случае можно использовать непосредственно значения косиниусов или сунусов сравниваемых углов, если только значения рассматриваемых углов не выходят за пределы участков монотонности этих функций.

Для вычисления скалярного произведения векторов ранеее была определена функция

```julia
LinearAlgebra.dot(A::Vector2D{T}, B::Vector2D{T}) where T = dot(Tuple(A), Tuple(B))
```

### Косое произведение векторов

От векторного произведения двух векторов **косое произведение** отличается тем, что результатом будет не сам вектор, ортогональный плоскости, определяемой этими двумя векторами, а лишь коэффициент при нормали к этой плоскости.

Рассмотрим выражение векторного произведения через координаты векторов, лежащих в плоскости `OXY`

$$
\vec{a}\times \vec{b} =
\begin{vmatrix}
\vec{i} & \vec{j} & \vec{k}\\
a_x & a_y & 0\\
b_x & b_y & 0
\end{vmatrix}=(a_x\cdot b_y - b_x\cdot a_y)\cdot \vec{k}
$$

Откуда получаем выражение искомого косого произведения:

$$a_x\cdot b_y - b_x\cdot a_y$$

Ранее нами была определена соответствующая функция 

```julia
xdot(A::Vector2D{T}, B::Vector2D{T}) where T = A.x*B.y-A.y*B.x
```

## Задача определения, лежат ли две заданные точки плоскости по одну сторону от границы заданной области

### Случай, когда граница граница представляет собой некоторую прямую, разделяюшую плоскость на две полуплоскости

Пусть $s=[A, B]$, некоторый сегмент рассматриваемой прямой, и $P$, $Q$ - пара точек, про которые требуется ответить, лежат ли они по одну сторону от прямой, или нет.

Определим направляющий вектор прямой $\vec l=\overrightarrow{AB}$. Тогда, точки $P$, $Q$ лежат по одну сторону от прямой тогда и только тогда, когда угол между векторами $\vec l$, $\overrightarrow{AP}$ и угол между векторами $\vec l$, $\overrightarrow{AQ}$ имеют один и тот же знак (отложены в одну и ту же сторону от прямой).

Функция, возвращающая значение `true`, если точки лежат по одну сторону от заданной прямой может быть определена так:

```julia
function is_one(P::Vector2D{T}, Q::Vector2D{T}, s::Sedment2D{T}) where T 
    l = s.B-s.A
    return sin(l, P-s.A)*sin(l,Q-s.A)>0
end
```

### Более общий способ

Ту же задачу можно решить и другим, более оющим способом. Для этого должно быть задано уравнение границы некотрой области.

Пусть граница определена своим неявным уравнением

$$
F(x,y)=0
$$

где $F(x,y)$ - некотрая непрерывная функция.

В частности это уравнение может представлять собой и уравнеие прямой, проходящей через две точки $A,B$:

$$
(𝑥−𝐴.𝑥)(𝐵.𝑦−𝐴.𝑦)−(𝑦−𝐴.𝑦)(𝐵.𝑥−𝐴.𝑥)=0
$$

Тогда неравенство

$$
F(x,y)<0
$$

разбивает все точки плоскости на 2 области: для двух точек $P$, $Q$ лежащих в одной и той же области данное неравенство выполняется или не выполняется одновременно.

Тогда, если определить:

```julia
is_one_area(F::Function, P::Vector2D{T}, Q::Vector2D{T}) where T = (F(P...)*F(Q...)>0)
```

Здесь предполагается, что функция F - есть функция двух вещественных переменных, причем уравнение $F(x,y)=0$, определяет границу рассматривемой плоской области.

В частности, если речь идет о прямолинейной границе, определяемой некоторым сегментом (s::Segment2D), то функция F будет определена выражением

```julia
(𝑥−s.𝐴.𝑥)(s.𝐵.𝑦−s.𝐴.𝑦)−(𝑦−s.𝐴.𝑦)(s.𝐵.𝑥−s.𝐴.𝑥)
```

## Задача определения, лежит ли заданная точка плоскости внутри заданного выпуклого многоугольника

Один из возможных вариантов решения следующий.

Если многоугольник выпуклый, как это предполагается, то из любой его внутренней точки будут "видны" все его вершины. Во входном массиве, по предположению, эти вершины перечисляются в порядке обхода границы (в каком-то из двух возможных направлений, всё равно в каком).

Тогда можно найти знак угла между вектором, направленном из заданной точки на некоторую вершину границы, и вектором, направленном из той же точки на следующую (в порядке обхода) вершину границы. При этом выжен будет только его знак этого угла.

Очевидно, что многоугольник выпуклый, тогда и только тогда, когда не будет происходить изменение знака угла при полном таком переборе всех пар соседних вершин. Сложность алгоритма, очевидно, оценивается как $O(n)$, где $n$ - число вершин многоугольника.

## Задача определения, является ли заданный плоский многоугольник выпуклым

Возможен следующий алгоритм, с оценкой сложности $O(n)$, где $n$ - число вершин многоугольника.

Опять будем исходить из дополнительного предположения о том, что вершины перечисляются во входном массиве, в каком-то одном из двух возможных, порядке обхода границы.

Тогда можно последовательно перебирая вершины многоугольника вычислять соответствующие его углы. У выпуклого многоугольника все эти углы будут меньше 180 градусов (или, если будем вычислять внешние углы, то все они - больше 180 градусов). А у не выпуклого многоугольника обязательно найдутся, как углы меньшие, так и большие 180 градусов.

## Задача построения выпуклой оболочки заданного множества точек плоскости

Задача ставится так. Дан некоторый массив координат точек плоскости. Требуется определить, какие из этих точек являются вершинами наименьшего выпуклого многоугольника, содержащего все остальные точки. Это наименьший многоугольник и называется **выпуклой оболочкой** заданного набора точек плоскости.

Понятие выпуклой оболочки поясняет следующий рисунок ![рисунок 2](lecture_2_5_fig-2.png)

Нарисунке показано, что если в точки "забить гвоздики", и поверх всех гвоздиков надеть хозяйственную резинку, то эта резинка примет форму выпуклой оболочки заданных точек.

Расмотрим несколько популярных алгоритмов построения выпуклой оболочки.

### Алгоритм Джарвиса

![Рисунок 3](lecture_2_5_fig-3.png)

Этапы алгоритма

- В заданном массиве находится самая нижняя точка, обозначим её $P_1$, и выбирается начальное базовое направление $l_1$ (на рисунке вектор этого направления напрвлен по горизонтали врправо). Точка $P_1$ гарантированно войдет в выпуклую оболочку.
  
- Следующая точка, обозначим её $P_2$, которая гарантированно войдет в выпуклую оболочку, будет точка, направление на которую из точки $P_1$ с базовым направлением $\vec l_1$ будет составлять наименьший угол. После выбора этой точки следует выбрать новое базовое направлением $\vec l_2=\overrightarrow{P_1P_2}$.

- Далее каждая $k+1-ая$ точка, добавляемая в выпуклую оболочку, определяется как точка, угол между направлением на которую из $k$-ой точки, и $k$-ым базовым направлением $\vec l_k$ является минимальным.

Алгоритм завершается когда очередная точка выпуклой оболочки не совпадет с точкой $P_1$.

Сложность этого алгоритма в наихудшем случае, когда почти все заданные точки войдут в выпуклую оболочку, оценивается как $O(n^2)$, где $n$ - это число всех точек.

Однако, часто число точек, вошедших в выпуклую оболочку, много меньше числа всех точек. Если число всех точек выпуклой оболочки можно оценить функцией $O(g(n))$, то то оценка общей сложности алгоритма Джарвиса будет иметь вид $O(n\cdot g(n))$.
  
### Алгоритм Грехома

Алгоритм Грехома сводится к следующим этапам

- Находится базовая точка $P_1$ точно так же, как и в алгоритме Джарвиса, и выбирается то же самое базовое направление $\vec l_1$.
- Все остальные точки сортируются по возрастанию угла между вектором $\vec l_1$ и вектором $\overrightarrow{P_1P_k}$ для $k=2,3,...,n$.
  
- Далее в выпуклую оболочку гарантирваноо войдут следующие 2 точки, следующие в отсортированном порядке.
  
- Сдедующая точка, в отсортирванном порядке, помещается в выпуклую оболочку как бы временно. Т.е. эта точка помещается на вершину стека, в котором вконце-концов должна оказаться вся выпуклая оболочка, но следующих шагах алгоритма некоторые точки с вершины этого стека могут быть сняты. А именно, пусть в стеке уже имеется $k$ точек. Тогда прежде чем на его вершину будут помещена очередная точка, из него сначала должны быть извлечены все точки, наличие котрых делает "текущую оболочку" не выпуклой (под "текущей оболочкой" здесь понимается многоугольник, вершины которого находятся в данный момент в стеке и ещё одна его вершина - это новая точка из отсортированной последовательности точек).

Следующая серия рисунков поясняет работу данного алгоритма

![Рисунок 4](lecture_2_5_fig-4.png)

Так же работу этого алгоритма в динамеке можно посмотреть, например, [здесь](https://habr.com/ru/post/144921/)

## Задача вычисления ориентированной площади плоского многоугольника (любого)

Задача ставится так: дана последователность точек - вершин произвольного многоугольника (допускаются даже пересечения его сторон), заданная в порядке обхода, например, против часовой стрелке (или по часовой стрелке - это не принципиально). Задание направление обхода означает, что граница многоугольника является ориентированной. Требуется вычислить площадь этого многоугольника. Причем, если ориентация границы положительная (направление обхода против часовой стрелки), то и площадь будет положительной, в противном случае площади приписывается знак минус.

Известно несколько простых методов решения этой задачи.

- Метод трапеций, следующий рисунок поясняет суть этого метода
![рисунок 5](lecture_2_5_fig-5.png)
Двигаясь по границе многоугольника от вершины к вершине вдоль заданной ориентации границы, надо вычислять площади трапеций одна из боковых сторон которых есть некоторое ребро многоугольникам(см.рисунок), причем периметры этих трапеций надо рассмативать как ориентированные границы, ориентация которых задаётся ориентацией самого многоугольника. Просуммировав полощади трапеций с нужными знаками, найдём полощадь многоугольника. Вычислять площади треугольников удобнее всего с помощью косого произведения, т.е. с помощью написанной нами функции `xdot`.

- Метод треугольника. Этот метод аналогичен методу трапеций, только вместо трапеций используются треугольники. Суть этого метода поясняется на следующем рисунке
![рисунок 6](lecture_2_5_fig-6.png)

- Существует ещё формула Гаусса для площади многоугольника
[формула Гаусса](https://ru.wikipedia.org/wiki/Формула_Площади_Гаусса)
